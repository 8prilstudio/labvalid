<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LabValid - Method Comparison Tool</title>
    <!-- Add hCaptcha script -->
    <script src="https://js.hcaptcha.com/1/api.js?onload=onHCaptchaLoad" async defer></script>
    
    <!-- DEBUGGING SCRIPT - REMOVE AFTER FIXING ISSUES -->
    <script>
        // This script runs immediately to help debug developer tools detection
        console.log("DEBUG: Page starting to load - " + new Date().toISOString());
        
        // Override document.body.innerHTML to catch any attempts to replace the page content
        const originalInnerHTML = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
        Object.defineProperty(Element.prototype, 'innerHTML', {
            set: function(value) {
                console.log("DEBUG: innerHTML being set to:", value.substring(0, 100) + "...");
                if (value.includes("Developer tools detected") || value.includes("Access denied")) {
                    console.error("DEBUG: Developer tools detection triggered! Stack trace:", new Error().stack);
                    // Prevent the page from being replaced
                    return;
                }
                // Otherwise proceed normally
                return originalInnerHTML.set.call(this, value);
            },
            get: function() {
                return originalInnerHTML.get.call(this);
            }
        });
        
        // Listen for any resize events that might trigger dev tools detection
        window.addEventListener('resize', function() {
            console.log("DEBUG: Window resized - might trigger detection");
            console.log("DEBUG: outerWidth:", window.outerWidth, "innerWidth:", window.innerWidth);
            console.log("DEBUG: outerHeight:", window.outerHeight, "innerHeight:", window.innerHeight);
        });
        
        // Monitor intervals that might be checking for dev tools
        const originalSetInterval = window.setInterval;
        window.setInterval = function(callback, delay) {
            console.log("DEBUG: setInterval called with delay:", delay);
            if (delay === 1000) {
                console.log("DEBUG: Suspicious interval detected - might be dev tools check");
                console.log("DEBUG: Stack trace:", new Error().stack);
            }
            return originalSetInterval(callback, delay);
        };
        
        // When page loads, check for suspicious inline scripts
        window.addEventListener('DOMContentLoaded', function() {
            console.log("DEBUG: Checking for suspicious inline scripts");
            const scripts = document.querySelectorAll('script:not([src])');
            scripts.forEach((script, index) => {
                const content = script.textContent;
                if (content.includes('devtools') || content.includes('DevTools') || 
                    content.includes('outerWidth') || content.includes('outerHeight') ||
                    content.includes('threshold') || content.includes('keyCode') ||
                    content.includes('detectDevTools') || content.includes('Access denied')) {
                    console.error(`DEBUG: Found suspicious script #${index}:`, content.substring(0, 150) + "...");
                }
            });
        });
    </script>
    
    <!-- Add a simple console log to check if JavaScript is running -->
    <script>
        console.log('Page is loading...');
        window.addEventListener('DOMContentLoaded', function() {
            console.log('DOM fully loaded');
            // Diagnostic message removed - no longer needed
        });
    </script>
    
    <!-- Supabase Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <!-- Supabase Initialization -->
    <script>
        // Initialize Supabase client - Replace these with your actual Supabase project details
        const supabaseUrl = 'https://ttkegyxxrkhyxhkaqxyx.supabase.co'; // Actual Supabase URL
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR0a2VneXh4cmtoeXhoa2FxeHl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0MTI4NDIsImV4cCI6MjA2MDk4ODg0Mn0.mhyvu0VNzzhHaVlFryXueXl0jR2ruAvhtj8Jpt87ebE'; // Actual public anon key
        
        // Use a different variable name to avoid conflicts
        try {
            // Make this a global variable to avoid "not defined" errors
            window.supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);
            console.log("Supabase initialized successfully");
            
            // Set up UI functions and event handlers only once DOM is loaded
            window.addEventListener('DOMContentLoaded', function() {
                // Test Supabase connection
                async function testSupabaseConnection() {
                    try {
                        const { data, error } = await window.supabaseClient.auth.getSession();
                        if (error) {
                            console.error('Supabase connection error:', error.message);
                        } else {
                            console.log('Connected to Supabase successfully!', data);
                        }
                    } catch (err) {
                        console.error('Unexpected error connecting to Supabase:', err.message);
                    }
                }
                
                // Check current user session
                async function checkUser() {
                    try {
                        const { data: { session } } = await window.supabaseClient.auth.getSession();
                        if (session) {
                            console.log('User is logged in:', session.user);
                            updateUIForAuthState(true, session.user);
                        } else {
                            console.log('No user logged in');
                            updateUIForAuthState(false);
                        }
                    } catch (err) {
                        console.error('Error checking user session:', err.message);
                    }
                }
                
                // Initialize UI based on authentication state
                function updateUIForAuthState(isAuthenticated, user = null) {
                    const authButton = document.getElementById('authButton');
                    const userMenu = document.getElementById('userMenu');
                    
                    if (!authButton || !userMenu) return; // Elements don't exist yet
                    
                    if (isAuthenticated && user) {
                        // User is logged in
                        authButton.style.display = 'none';
                        userMenu.style.display = 'block';
                        
                        // Update user details
                        const userEmail = document.getElementById('userEmail');
                        const userInitials = document.getElementById('userInitials');
                        
                        if (userEmail) userEmail.textContent = user.email;
                        if (userInitials) userInitials.textContent = user.email.substring(0, 2).toUpperCase();
                        
                        // Fetch and update token balance
                        fetchTokenBalance(user.id);
                    } else {
                        // User is logged out
                        authButton.style.display = 'inline-block';
                        userMenu.style.display = 'none';
                    }
                }
                
                // Function to fetch token balance
                async function fetchTokenBalance(userId) {
                    try {
                        if (!userId) {
                            console.error('Error fetching tokens: No user ID provided');
                            return;
                        }
                        
                        const { data, error } = await window.supabaseClient
                            .from('user_tokens')
                            .select('tokens')
                            .eq('user_id', userId)
                            .single();
                        
                        if (error) {
                            console.error('Error fetching tokens:', error.message, error.details, error.hint);
                            return;
                        }
                        
                        if (data) {
                            updateTokenDisplay(data.tokens);
                        } else {
                            // No token record exists yet
                            console.log('No token record found for user, creating one...');
                            createInitialTokenBalance(userId);
                        }
                    } catch (err) {
                        console.error('Unexpected error fetching token balance:', err);
                    }
                }
                
                // Function to create initial token balance
                async function createInitialTokenBalance(userId) {
                    try {
                        const initialTokens = 5; // Start with 5 free tokens
                        
                        // Use upsert operation instead of insert to handle potential duplicates
                        const { data, error } = await window.supabaseClient
                            .from('user_tokens')
                            .upsert([
                                { user_id: userId, tokens: initialTokens }
                            ], { onConflict: 'user_id' })
                            .select();
                        
                        if (error) {
                            console.error('Error creating initial token balance:', error);
                            return;
                        }
                        
                        console.log('Initial token balance created:', data);
                        updateTokenDisplay(initialTokens);
                    } catch (err) {
                        console.error('Unexpected error creating token balance:', err);
                    }
                }
                
                // Function to update token display
                function updateTokenDisplay(tokenCount) {
                    const tokenBalance = document.getElementById('tokenBalance');
                    if (tokenBalance) {
                        tokenBalance.textContent = tokenCount;
                    }
                }
                
                // Function to deduct tokens
                async function deductToken() {
                    try {
                        const { data: { session } } = await window.supabaseClient.auth.getSession();
                        
                        if (!session) {
                            console.error('No user session found');
                            return false;
                        }
                        
                        const userId = session.user.id;
                        
                        // Check if we're in fallback mode
                        if (window.userTokenBalance !== undefined) {
                            // We're in fallback mode, use in-memory tokens
                            if (window.userTokenBalance < 1) {
                                alert('You do not have enough tokens to perform this analysis. Please purchase more tokens.');
                                return false;
                            }
                            
                            // Deduct token
                            window.userTokenBalance--;
                            
                            // Try to update localStorage as well
                            try {
                                localStorage.setItem(`tokenBalance_${userId}`, window.userTokenBalance);
                            } catch (e) {
                                console.warn('Could not save to localStorage:', e);
                            }
                            
                            // Update display
                            updateTokenDisplay(window.userTokenBalance);
                        }
                    } catch (err) {
                        console.error('Unexpected error during token deduction:', err);
                        return false;
                    }
                }
                
                // Handle logout
                window.handleLogout = async function() {
                    try {
                        const { error } = await window.supabaseClient.auth.signOut();
                        if (error) {
                            console.error('Logout error:', error);
                        } else {
                            updateUIForAuthState(false);
                        }
                    } catch (err) {
                        console.error('Unexpected logout error:', err);
                    }
                };
                
                // Toggle between login and signup forms
                window.toggleForms = function(form) {
                    const loginForm = document.getElementById('loginForm');
                    const signupForm = document.getElementById('signupForm');
                    const resetPasswordForm = document.getElementById('resetPasswordForm');
                    
                    if (!loginForm || !signupForm || !resetPasswordForm) return; // Elements don't exist
                    
                    // Hide all forms first
                    loginForm.style.display = 'none';
                    signupForm.style.display = 'none';
                    resetPasswordForm.style.display = 'none';
                    
                    // Reset hCaptcha if leaving signup form
                    if (form !== 'signup' && typeof hcaptcha !== 'undefined') {
                        hcaptcha.reset();
                    }
                    
                    // Show the requested form
                    if (form === 'login') {
                        loginForm.style.display = 'flex';
                    } else if (form === 'signup') {
                        signupForm.style.display = 'flex';
                    } else if (form === 'resetPassword') {
                        resetPasswordForm.style.display = 'flex';
                    }
                    
                    // Clear any previous messages
                    const loginMessage = document.getElementById('loginMessage');
                    const signupMessage = document.getElementById('signupMessage');
                    const resetMessage = document.getElementById('resetMessage');
                    if (loginMessage) loginMessage.style.display = 'none';
                    if (signupMessage) signupMessage.style.display = 'none';
                    if (resetMessage) resetMessage.style.display = 'none';
                };
                
                // hCaptcha callback functions
                window.onHCaptchaLoad = function() {
                    console.log('hCaptcha loaded successfully');
                };
                
                window.onHCaptchaSuccess = function(token) {
                    console.log('hCaptcha verification successful');
                };
                
                window.onHCaptchaError = function(error) {
                    console.error('hCaptcha error:', error);
                };
                
                // Show/hide the auth modal
                window.toggleAuthModal = function(show) {
                    const modal = document.getElementById('authModal');
                    if (!modal) return; // Element doesn't exist
                    
                    modal.style.display = show ? 'flex' : 'none';
                    
                    // Reset to login form when opening
                    if (show) {
                        window.toggleForms('login');
                    }
                };
                
                // Show an auth message (success or error)
                window.showAuthMessage = function(elementId, message, isError = false) {
                    const messageElement = document.getElementById(elementId);
                    if (!messageElement) return; // Element doesn't exist
                    
                    messageElement.textContent = message;
                    messageElement.style.display = 'block';
                    
                    if (isError) {
                        messageElement.classList.add('error');
                        messageElement.classList.remove('success');
                    } else {
                        messageElement.classList.add('success');
                        messageElement.classList.remove('error');
                    }
                };
                
                // Set up event listeners for authentication
                function setupAuthEventListeners() {
                    // Auth button click
                    const authButton = document.getElementById('authButton');
                    if (authButton) {
                        authButton.addEventListener('click', function() {
                            window.toggleAuthModal(true);
                        });
                    }
                    
                    // User menu button click
                    const userMenuButton = document.getElementById('userMenuButton');
                    if (userMenuButton) {
                        userMenuButton.addEventListener('click', function() {
                            const dropdown = document.getElementById('userDropdown');
                            dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
                        });
                    }
                    
                    // Close dropdown when clicking outside
                    document.addEventListener('click', function(e) {
                        const userMenu = document.getElementById('userMenu');
                        const userDropdown = document.getElementById('userDropdown');
                        if (userMenu && userDropdown && !userMenu.contains(e.target)) {
                            userDropdown.style.display = 'none';
                        }
                    });
                    
                    // Login form submit
                    const loginForm = document.getElementById('loginForm');
                    if (loginForm) {
                        loginForm.addEventListener('submit', async function(e) {
                            e.preventDefault();
                            
                            const email = document.getElementById('loginEmail').value;
                            const password = document.getElementById('loginPassword').value;
                            
                            try {
                                const { data, error } = await window.supabaseClient.auth.signInWithPassword({
                                    email,
                                    password
                                });
                                
                                if (error) {
                                    window.showAuthMessage('loginMessage', error.message, true);
                                } else {
                                    window.showAuthMessage('loginMessage', 'Login successful!');
                                    // Close the modal after a short delay
                                    setTimeout(() => {
                                        window.toggleAuthModal(false);
                                        updateUIForAuthState(true, data.user);
                                    }, 1000);
                                }
                            } catch (err) {
                                window.showAuthMessage('loginMessage', 'An unexpected error occurred.', true);
                                console.error('Login error:', err);
                            }
                        });
                    }
                    
                    // Signup form submit
                    const signupForm = document.getElementById('signupForm');
                    if (signupForm) {
                        signupForm.addEventListener('submit', async function(e) {
                            e.preventDefault();
                            
                            const email = document.getElementById('signupEmail').value;
                            const password = document.getElementById('signupPassword').value;
                            
                            // Verify hCaptcha
                            const hcaptchaResponse = hcaptcha.getResponse();
                            if (!hcaptchaResponse) {
                                window.showAuthMessage('signupMessage', 'Please complete the captcha verification.', true);
                                return;
                            }
                            
                            try {
                                // Show loading state
                                window.showAuthMessage('signupMessage', 'Creating your account...', false);
                                
                                // First verify the hCaptcha token on your server
                                // For demo purposes, we'll pretend it's verified and proceed directly
                                // In production, you should send the token to your server for verification
                                
                                const { data, error } = await window.supabaseClient.auth.signUp({
                                    email,
                                    password,
                                    options: {
                                        data: {
                                            captchaVerified: true
                                        }
                                    }
                                });
                                
                                if (error) {
                                    console.error("Signup error:", error);
                                    window.showAuthMessage('signupMessage', error.message, true);
                                    // Reset hCaptcha on error
                                    hcaptcha.reset();
                                } else {
                                    console.log("Signup success:", data);
                                    
                                    // Create initial token balance if user is created
                                    if (data.user && data.user.id) {
                                        try {
                                            await createInitialTokenBalance(data.user.id);
                                        } catch (err) {
                                            console.error("Error setting up initial tokens:", err);
                                        }
                                    }
                                    
                                    window.showAuthMessage('signupMessage', 'Registration successful! Please check your email for confirmation.');
                                    // Switch back to login after a short delay
                                    setTimeout(() => {
                                        window.toggleForms('login');
                                    }, 2000);
                                }
                            } catch (err) {
                                console.error('Unexpected error during signup:', err);
                                window.showAuthMessage('signupMessage', 'An unexpected error occurred: ' + err.message, true);
                            }
                        });
                    }
                    
                    // Reset password form submit
                    const resetPasswordForm = document.getElementById('resetPasswordForm');
                    if (resetPasswordForm) {
                        resetPasswordForm.addEventListener('submit', async function(e) {
                            e.preventDefault();
                            
                            const email = document.getElementById('resetEmail').value;
                            
                            try {
                                window.showAuthMessage('resetMessage', 'Processing your request...', false);
                                
                                const { error } = await window.supabaseClient.auth.resetPasswordForEmail(email, {
                                    redirectTo: 'https://labvalid.com', // Use your actual domain instead of localhost
                                });
                                
                                if (error) {
                                    console.error("Password reset error:", error);
                                    window.showAuthMessage('resetMessage', error.message, true);
                                } else {
                                    window.showAuthMessage('resetMessage', 'Check your email for password reset instructions!');
                                    // Keep the message visible so user can read it
                                }
                            } catch (err) {
                                console.error('Password reset error:', err);
                                window.showAuthMessage('resetMessage', 'An unexpected error occurred.', true);
                            }
                        });
                    }
                }
                
                // Run initialization
                testSupabaseConnection();
                checkUser();
                setupAuthEventListeners();
                setupTokenPurchaseListeners();
            });
            
            function setupTokenPurchaseListeners() {
                const purchaseButton = document.getElementById('purchaseButton');
                if (purchaseButton) {
                    purchaseButton.addEventListener('click', async function() {
                        if (!window.selectedTokenPackage || window.selectedTokenPackage <= 0) return;
                        
                        try {
                            const { data: { session } } = await window.supabaseClient.auth.getSession();
                            
                            if (!session) {
                                console.error('No user session found');
                                alert('Please log in to purchase tokens');
                                window.closeTokenPurchaseModal();
                                return;
                            }
                            
                            // In a real app, this would connect to a payment system
                            // For this demo, we'll simply add the tokens directly
                            
                            // First, get current tokens
                            const { data: tokenData, error: fetchError } = await window.supabaseClient
                                .from('user_tokens')
                                .select('tokens')
                                .eq('user_id', session.user.id)
                                .single();
                            
                            if (fetchError) {
                                console.error('Error fetching token balance:', fetchError);
                                alert('Error processing purchase. Please try again.');
                                return;
                            }
                            
                            // Update token balance
                            const currentTokens = tokenData ? tokenData.tokens : 0;
                            const newBalance = currentTokens + window.selectedTokenPackage;
                            
                            const { error: updateError } = await window.supabaseClient
                                .from('user_tokens')
                                .update({ tokens: newBalance })
                                .eq('user_id', session.user.id);
                            
                            if (updateError) {
                                console.error('Error updating token balance:', updateError);
                                alert('Error processing purchase. Please try again.');
                                return;
                            }
                            
                            // Update display
                            updateTokenDisplay(newBalance);
                            
                            // Show success message
                            alert(`Successfully purchased ${window.selectedTokenPackage} tokens!`);
                            
                            // Close modal
                            window.closeTokenPurchaseModal();
                        } catch (err) {
                            console.error('Unexpected error during token purchase:', err);
                            alert('Error processing purchase. Please try again.');
                        }
                    });
                }
            }
            
            // Rest of your existing script...
        } catch (error) {
            console.error("Error initializing Supabase:", error);
            // Show user-friendly error message
            const warningBanner = document.createElement('div');
            warningBanner.style.background = '#ffcc00';
            warningBanner.style.color = '#333';
            warningBanner.style.padding = '10px';
            warningBanner.style.textAlign = 'center';
            warningBanner.textContent = 'Warning: Some features may not be available due to loading issues.';
            document.body.prepend(warningBanner);
        }
    </script>

    <!-- Error logging for script loading -->
    <script>
        window.addEventListener('error', function(e) {
            if (e.target.tagName === 'SCRIPT') {
                console.error('Script loading error for:', e.target.src);
            }
        }, true);
    </script>
    
    <style>
        :root {
            --primary-color: #1EAEAE; /* Updated to match teal from new logo */
            --secondary-color: #1A2C4E; /* Updated to match navy from new logo */
            --accent-color: #e91e63;
            --background-color: #f8fafc;
            --card-background: #ffffff;
            --text-primary: #1A2C4E; /* Updated to match navy from new logo */
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
        }

        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
              Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: var(--background-color);
            color: var(--text-primary);
            line-height: 1.5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--card-background);
            border-radius: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .header-buttons {
            display: flex;
            align-items: center;
        }

        .about-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .about-button:hover {
            background-color: #008c8c;
        }
        
        .logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }
        
        .logo {
            height: 5.5rem; /* Doubled from 2.75rem */
            width: auto;
            flex-shrink: 0;
        }

        .logo-text {
            font-size: 2.5rem;
            color: var(--secondary-color);
            margin: 0;
            font-weight: 600;
            line-height: 1;
        }
        
        .card {
            background-color: var(--card-background);
            border-radius: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: transform 0.2s ease-in-out;
        }

        .card:hover {
            transform: translateY(-2px);
        }
        
        h1, h2, h3, h4 {
            color: var(--secondary-color);
            margin-top: 0;
        }

        h2 {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary-color);
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        .form-label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }
        
        input[type="file"],
        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: border-color 0.2s ease;
            background-color: var(--card-background);
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 181, 181, 0.1);
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        button:hover {
            background-color: #009595;
            transform: translateY(-1px);
        }
        
        button:disabled {
            background-color: var(--text-secondary);
            cursor: not-allowed;
            transform: none;
        }

        .export-btn {
            width: 100%;
            margin-top: 1rem;
        }

        #exportWordButton {
            background-color: var(--secondary-color);
        }

        #exportWordButton:hover {
            background-color: #142b4e;
        }
        
        .chart-container {
            height: 400px;
            margin: 1.5rem 0;
            position: relative;
            border-radius: 0.5rem;
            overflow: hidden;
            background-color: var(--card-background);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .two-column {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }
        
        @media (min-width: 768px) {
            .two-column {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .stats-container {
            padding-top: 1.5rem;
            border-top: 2px solid var(--border-color);
            margin-top: 1.5rem;
        }
        
        .chart-download-container {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background-color: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 5;
        }
        
        .chart-download-btn {
            background-color: var(--accent-color);
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }
        
        .chart-download-btn:hover {
            background-color: #c2185b;
        }
        
        .download-format {
            padding: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            text-align: center;
            transition: background-color 0.2s ease;
            border-radius: 0.25rem;
        }
        
        .download-format:hover {
            background-color: var(--border-color);
        }
        
        .smart-interpretation-btn {
            width: 100%;
            background-color: var(--secondary-color);
            margin: 1rem 0;
        }

        .smart-interpretation-btn:hover {
            background-color: #142b4e;
        }

        .interpretation-content {
            background-color: #f8fafc;
            padding: 1rem;
            border-radius: 0.5rem;
            border-left: 4px solid var(--primary-color);
        }
        
        .note {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-style: italic;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            background-color: var(--card-background);
            border-radius: 0.5rem;
            overflow: hidden;
        }

        th, td {
            padding: 1rem;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: #f8fafc;
        }

        .ci-selector {
            margin-top: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            background-color: #f8fafc;
            padding: 1rem;
            border-radius: 0.5rem;
        }
        
        .ci-selector select {
            width: auto;
            margin: 0;
        }

        .example-overlay {
            position: relative;
            overflow: hidden;
        }
        
        .example-overlay::before {
            content: "EXAMPLE";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.35);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
        }

        /* Ensure the content is visible above the overlay */
        .example-overlay > * {
            position: relative;
            z-index: 1;
        }

        .info-card {
            background-color: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            display: none; /* Hidden by default */
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .info-button {
            position: static;
            padding: 0.25rem 0.5rem;
            background-color: transparent;
            color: var(--primary-color);
            border: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.2s ease;
            margin-left: 0.5rem;
            vertical-align: middle;
        }

        .info-button:hover {
            transform: scale(1.1);
            color: #009595;
        }

        .info-button:active {
            transform: scale(0.95);
        }

        .section-header {
            display: flex;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .section-header h2 {
            margin: 0;
            border: none;
        }

        .info-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
            animation: fadeIn 0.3s ease-in-out;
        }

        .info-modal {
            background-color: white;
            border-radius: 1rem;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            animation: slideIn 0.3s ease-in-out;
        }

        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .close-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s ease;
        }

        .close-button:hover {
            color: var(--text-primary);
            transform: none;
        }

        .info-card h3 {
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-card h3::before {
            content: "ℹ️";
            font-size: 1.25rem;
        }

        .requirements-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .requirements-list li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
        }

        .requirements-list li::before {
            content: "✓";
            color: var(--success-color);
            position: absolute;
            left: 0;
            font-weight: bold;
        }

        .excel-template {
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
        }

        .excel-template table {
            margin: 0;
            font-size: 0.875rem;
        }

        .excel-template th {
            background-color: #e5e7eb;
            color: var(--text-primary);
        }

        .download-template-btn {
            background-color: var(--success-color);
            margin-top: 1rem;
            width: auto;
            font-size: 0.875rem;
        }

        .download-template-btn:hover {
            background-color: #059669;
        }

        .about-button {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            color: var(--primary-color);
            padding: 0.5rem 1rem;
            font-size: 1rem;
            text-transform: none;
            letter-spacing: normal;
        }

        .about-button:hover {
            color: var(--secondary-color);
            background: transparent;
        }

        .method-comparison-section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: #f8fafc;
            border-radius: 0.5rem;
            border-left: 4px solid var(--primary-color);
        }

        .method-comparison-section h4 {
            color: var(--primary-color);
            margin-bottom: 1rem;
        }

        .step-list {
            list-style: none;
            padding: 0;
            margin: 0;
            counter-reset: step-counter;
        }

        .step-list li {
            position: relative;
            padding: 0.5rem 0 0.5rem 2rem;
            counter-increment: step-counter;
        }

        .step-list li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0.5rem;
            width: 1.5rem;
            height: 1.5rem;
            background-color: var(--primary-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: bold;
        }

        .key-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .feature-card {
            background-color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
        }

        .feature-card h5 {
            color: var(--secondary-color);
            margin: 0 0 0.5rem 0;
            font-size: 1rem;
        }

        .feature-card p {
            margin: 0;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }

        .modal-content {
            background-color: var(--card-background);
            margin: 2rem auto;
            padding: 2rem;
            border-radius: 1rem;
            max-width: 800px;
            position: relative;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .modal-close {
            position: absolute;
            right: 1rem;
            top: 1rem;
            background: transparent;
            color: var(--text-secondary);
            padding: 0.5rem;
            font-size: 1.5rem;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--text-primary);
            background: transparent;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .feature-item {
            padding: 1.5rem;
            border-radius: 0.5rem;
            background-color: var(--background-color);
            border: 1px solid var(--border-color);
        }

        .feature-item h3 {
            color: var(--primary-color);
            margin-top: 0;
        }

        .help-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 5px;
            transition: background-color 0.3s;
        }

        .help-button:hover {
            background-color: #008c8c;
        }

        .help-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .help-modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            position: relative;
        }

        .help-modal-close {
            position: absolute;
            right: 10px;
            top: 10px;
            font-size: 20px;
            cursor: pointer;
        }

        /* Add styles for authentication components */
        .auth-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .auth-modal {
            background-color: var(--card-background);
            border-radius: 0.75rem;
            padding: 2rem;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .auth-modal h2 {
            text-align: center;
            margin-bottom: 1.5rem;
        }
        
        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .auth-form input {
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        
        .auth-form button {
            margin-top: 0.5rem;
        }
        
        /* hCaptcha container styles */
        .h-captcha {
            display: flex;
            justify-content: center;
            margin: 15px 0;
        }
        
        .auth-toggle {
            margin-top: 1rem;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .auth-toggle a {
            color: var(--primary-color);
            text-decoration: none;
            cursor: pointer;
        }
        
        .close-button {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-secondary);
            cursor: pointer;
        }
        
        .login-button {
            background-color: var(--secondary-color);
            margin-left: 0.5rem;
        }
        
        .login-button:hover {
            background-color: #142b4e;
        }
        
        .auth-message {
            margin-top: 1rem;
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
            display: none;
        }
        
        .auth-message.error {
            background-color: #fee2e2;
            color: #ef4444;
        }
        
        .auth-message.success {
            background-color: #dcfce7;
            color: #10b981;
        }
        
        .user-menu {
            position: relative;
            display: none;
        }
        
        .user-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background-color: var(--card-background);
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: none;
            z-index: 100;
            min-width: 150px;
        }
        
        .user-dropdown-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }
        
        .user-dropdown-item:hover:not(.user-email):not(.tokens-display) {
            background-color: #f5f5f5;
        }
        
        .user-email, .tokens-display {
            cursor: default;
            font-weight: 500;
        }
        
        .tokens-display {
            color: var(--secondary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #tokenBalance {
            font-weight: bold;
            color: var(--primary-color);
        }

        .user-button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .user-button:hover {
            background-color: #142b4e;
        }

        .small-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 16px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .small-button:hover {
            background-color: #008c8c;
        }
        
        /* Token Purchase Modal Styles */
        .token-packages {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .token-package {
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            width: 120px;
            text-align: center;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .token-package:hover {
            border-color: var(--primary-color);
            transform: translateY(-5px);
        }
        
        .token-package.selected {
            border-color: var(--primary-color);
            background-color: rgba(30, 174, 174, 0.1);
        }
        
        .token-count {
            font-size: 24px;
            font-weight: bold;
            color: var(--secondary-color);
            margin-bottom: 5px;
        }
        
        .token-price {
            font-size: 18px;
            color: var(--text-primary);
            margin-bottom: 5px;
        }
        
        .token-label {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .token-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: var(--accent-color);
            color: white;
            font-size: 12px;
            padding: 3px 6px;
            border-radius: 10px;
            font-weight: bold;
        }
        
        .token-purchase-footer {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
        
        .purchase-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .purchase-button:hover:not(:disabled) {
            background-color: #008c8c;
        }
        
        .purchase-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@3.0.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html-docx-js@0.3.1/dist/html-docx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    
    <!-- Removed reCAPTCHA script to fix signup issues -->
    
    <!-- Fallback script in case external libraries fail to load -->
    <script>
        window.addEventListener('load', function() {
            if (typeof Chart === 'undefined') {
                document.body.insertAdjacentHTML('afterbegin', 
                    '<div style="background:orange;color:black;padding:10px;text-align:center;">' +
                    'Warning: Some external libraries failed to load. The application may not function correctly.' +
                    '</div>'
                );
            }
        });
    </script>
    <script>
        // Move toggle functions outside of DOMContentLoaded
        function toggleInfo() {
            const overlay = document.getElementById('infoOverlay');
            if (overlay.style.display === 'flex') {
                overlay.style.display = 'none';
                document.body.style.overflow = 'auto';
            } else {
                overlay.style.display = 'flex';
                document.body.style.overflow = 'hidden';
            }
        }

        // Initialize event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Info modal listeners
            document.getElementById('infoOverlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    toggleInfo();
                }
            });

            // Global escape key listener
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    const infoOverlay = document.getElementById('infoOverlay');
                    
                    
                    if (infoOverlay.style.display === 'flex') {
                        toggleInfo();
                    }
                }
            });
        });

        function downloadTemplate() {
            try {
                // Create a workbook with example data
                const wb = XLSX.utils.book_new();
                const data = [
                    ['Reference Method', 'Test Method'],
                    [120.5, 118.7],
                    [95.2, 94.8],
                    [150.8, 152.3],
                    [85.4, 84.9],
                    [110.2, 111.5],
                    [75.6, 74.9],
                    [130.7, 131.2],
                    [90.3, 89.8],
                    [145.6, 146.1],
                    [105.8, 104.9]
                ];
                
                const ws = XLSX.utils.aoa_to_sheet(data);
                
                // Add some styling to the header row
                const range = XLSX.utils.decode_range(ws['!ref']);
                for(let C = range.s.c; C <= range.e.c; ++C) {
                    const address = XLSX.utils.encode_col(C) + "1";
                    if(!ws[address]) continue;
                    ws[address].s = {
                        font: { bold: true },
                        fill: { fgColor: { rgb: "CCCCCC" } }
                    };
                }
                
                // Auto-size columns
                const colWidths = data[0].map((_, i) => ({
                    wch: Math.max(...data.map(row => row[i].toString().length))
                }));
                ws['!cols'] = colWidths;
                
                XLSX.utils.book_append_sheet(wb, ws, 'Template');
                
                // Save the file
                XLSX.writeFile(wb, 'LabValid_Template.xlsx');
                console.log('Template downloaded successfully');
            } catch (error) {
                console.error('Error downloading template:', error);
                alert('Error creating template file. Please try again.');
            }
        }

        // Rest of your existing script...
    </script>
    <script>
        // DevTools detection has been removed
        (function() {
            // Allow developer tools for better debugging experience
            console.log("Developer tools are now allowed for better debugging experience");
            
            // Prevent right-click
            document.addEventListener('contextmenu', function(e) {
                // Contextmenu is now allowed
                return true;
            });

            // Security measures removed
            console.log("Security measures removed for better compatibility");
        })();
    </script>
    <style>
        /* Allow text selection */
        * {
            -webkit-user-select: auto;
            -moz-user-select: auto;
            -ms-user-select: auto;
            user-select: auto;
        }
    </style>
  </head>
  <body>
    <noscript>
        <div style="background:red;color:white;padding:20px;text-align:center;margin:20px;">
            <h2>JavaScript is Required</h2>
            <p>This application requires JavaScript to function. Please enable JavaScript in your browser settings and reload the page.</p>
        </div>
    </noscript>
    <div class="container">
        <div class="header">
            <div class="logo-container">
                <!-- Add fallback for logo in case path is an issue -->
                <img src="LabValid-Logo(2).png" alt="LabValid Logo" class="logo" onerror="this.onerror=null; this.src=''; this.alt='Logo not found'; console.error('Logo image failed to load');">
            </div>
            <div class="header-buttons">
                <button class="login-button" id="authButton">Login</button>
                <div class="user-menu" id="userMenu">
                    <button class="user-button" id="userMenuButton">
                        <span id="userInitials">AA</span>
                    </button>
                    <div class="user-dropdown" id="userDropdown">
                        <div class="user-dropdown-item user-email" id="userEmail">user@example.com</div>
                        <div class="user-dropdown-item tokens-display">
                            Tokens: <span id="tokenBalance">0</span>
                            <button class="small-button" onclick="showTokenPurchaseModal()">+</button>
                        </div>
                        <div class="user-dropdown-item" onclick="handleLogout()">Logout</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="info-overlay" id="infoOverlay" style="display: none;">
            <div class="info-modal">
                <button class="close-button" onclick="toggleInfo()">×</button>
                <div class="info-card" style="display: block; margin: 0;">
                    <h3>Excel Upload Guide</h3>
                    <p>To ensure successful data analysis, please follow these requirements when preparing your Excel file:</p>
                    
                    <ul class="requirements-list">
                        <li>File must be in <strong>.xlsx</strong> or <strong>.xls</strong> format</li>
                        <li>Data should be organized in columns with headers</li>
                        <li>Reference method values should be in <strong>Column A</strong> (starting from A1)</li>
                        <li>Test method values should be in <strong>Column B</strong> (starting from B1)</li>
                        <li>Each row should contain paired measurements from both analyzers</li>
                        <li>No missing values or non-numeric data in measurement columns</li>
                        <li>Minimum of 30 paired measurements recommended for reliable analysis</li>
                        <li>Maximum of 1000 paired measurements to ensure optimal performance</li>
                    </ul>

                    <div class="excel-template">
                        <h4 style="margin-top: 0;">Example Excel Format:</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Reference Method</th>
                                    <th>Test Method</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>120.5</td>
                                    <td>118.7</td>
                                </tr>
                                <tr>
                                    <td>95.2</td>
                                    <td>94.8</td>
                                </tr>
                            </tbody>
                        </table>
                        <button class="download-template-btn" onclick="downloadTemplate()">
                            📥 Download Template
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="section-header">
                <h2>Upload Data</h2>
                <div class="button-group">
                    <button class="info-button" onclick="toggleInfo()" title="Show Upload Guide">
                        ℹ️
                    </button>
                    <button class="example-button" onclick="toggleExample()" title="Show Example">
                        Click to show example
                    </button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">Choose Input Method:</label>
                <div style="margin-bottom: 1rem;">
                    <input type="radio" id="excelInputRadio" name="inputMethod" value="excel" checked>
                    <label for="excelInputRadio">Excel File Upload</label>
                    <input type="radio" id="directInputRadio" name="inputMethod" value="direct" style="margin-left: 1rem;">
                    <label for="directInputRadio">Direct Data Input</label>
                </div>
            </div>

            <div id="excelInputSection">
                <div class="form-group">
                    <label class="form-label">Select Excel File</label>
                    <input type="file" id="fileInput" accept=".xlsx, .xls" />
                </div>
            </div>

            <div id="directInputSection" style="display: none;">
                <div class="form-group">
                    <label class="form-label">Enter Your Data</label>
                    <textarea id="directDataInput" rows="10" class="form-control" placeholder="Enter your data in this format (include the header row with your column names):
Column1,Column2
2,2
4,8
6,8
7,9"></textarea>
                    <p class="note" style="margin-top: 0.5rem;">Enter your data with column headers in the first row, followed by your measurements. Use commas to separate values.</p>
                    <div id="inputValidation" style="margin-top: 0.5rem; color: var(--error-color); display: none;"></div>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Reference Method Name</label>
                <input type="text" id="currentAnalyzerInput" placeholder="e.g., Analyzer A" value="Reference Method" />
            </div>
            <div class="form-group">
                <label class="form-label">Test Method Name</label>
                <input type="text" id="newAnalyzerInput" placeholder="e.g., Analyzer B" value="Test Method" />
            </div>
        </div>
        
        <div class="card">
            <h2>Column Selection</h2>
            <div class="form-group">
                <label class="form-label">Reference Method Values</label>
                <select id="currentAnalyzerSelect" disabled>
                    <option value="">Select a column...</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Test Method Values</label>
                <select id="newAnalyzerSelect" disabled>
                    <option value="">Select a column...</option>
                </select>
            </div>
            <button id="analyzeButton" disabled>Analyze Data</button>
        </div>
        
        <div id="resultsContainer" style="display: none;">
            <div class="card" id="sampleCountCard">
                <h2>Sample Count</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                    <div>
                        <h4>Total Paired Samples</h4>
                        <p style="font-size: 24px; font-weight: bold; color: #2563eb;" id="totalSamplesCount">0</p>
                        <p style="color: #666; font-style: italic;">This represents the number of valid paired measurements used in the analysis</p>
                    </div>
                    <div>
                        <h4>Data Range</h4>
                        <p id="dataRangeInfo" style="font-size: 16px; color: #333;"></p>
                    </div>
                </div>
            </div>
            <div class="card" id="summarySectionCard">
                <h2>Summary of Key Results to Report</h2>
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; margin-top: 15px; border: 1px solid #ddd;">
                        <thead>
                            <tr style="background-color: #f5f5f5; border-bottom: 2px solid #ddd;">
                                <th style="padding: 12px 15px; text-align: left; border-right: 1px solid #ddd;">Statistic</th>
                                <th style="padding: 12px 15px; text-align: left; border-right: 1px solid #ddd;">What It Tells You</th>
                                <th style="padding: 12px 15px; text-align: left;">Ideal Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">Slope (β₁)</td>
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">Proportional bias</td>
                                <td style="padding: 12px 15px;">Close to 1, CI includes 1</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd; background-color: #f9f9f9;">
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">Intercept (β₀)</td>
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">Constant bias</td>
                                <td style="padding: 12px 15px;">Close to 0, CI includes 0</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">Correlation (r)</td>
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">Strength of association</td>
                                <td style="padding: 12px 15px;">r > 0.95 for strong agreement</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd; background-color: #f9f9f9;">
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">P-value for slope/intercept</td>
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">Significance of bias</td>
                                <td style="padding: 12px 15px;">p ≥ 0.05 (no significant bias)</td>
                            </tr>
                            <tr style="border-bottom: 1px solid #ddd;">
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">CUSUM test</td>
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">Linearity check</td>
                                <td style="padding: 12px 15px;">p ≥ 0.05 (linear relationship)</td>
                            </tr>
                            <tr style="background-color: #f9f9f9;">
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">Bland-Altman (Mean Bias, LOA)</td>
                                <td style="padding: 12px 15px; border-right: 1px solid #ddd;">Agreement range</td>
                                <td style="padding: 12px 15px;">Mean bias close to 0</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="card" id="currentResultsCard">
                <h2>Current Analysis Results</h2>
                <div id="currentResultsSummary" style="margin-top: 20px; padding: 15px; background-color: #f9f9f9; border-radius: 5px;"></div>
            </div>
            
            <div class="card" id="axisConfigCard">
                <h2>Passing-Bablok Regression - Axis Configuration</h2>
                <div class="two-column" style="gap: 30px; position: relative;">
                    <div style="border: 1px solid #e5e7eb; padding: 15px; border-radius: 5px; background-color: #f9fafb;">
                        <h3 style="color: #3b82f6; margin-top: 0;">X-Axis (Reference Method)</h3>
                        <div class="input-row">
                            <div>
                                <label class="form-label">Min Value</label>
                                <input type="number" id="xAxisMin" value="0" style="width: 90%; max-width: 120px;" />
                            </div>
                            <div>
                                <label class="form-label">Max Value</label>
                                <input type="number" id="xAxisMax" value="140" style="width: 90%; max-width: 120px;" />
                            </div>
                        </div>
                        <div class="input-row">
                            <div>
                                <label class="form-label">Interval</label>
                                <input type="number" id="xAxisInterval" value="20" min="5" style="width: 90%; max-width: 120px;" />
                            </div>
                        </div>
                        <p class="note">Smaller intervals may create crowded axis labels</p>
                    </div>
                    <div style="border: 1px solid #e5e7eb; padding: 15px; border-radius: 5px; background-color: #f9fafb;">
                        <h3 style="color: #ef4444; margin-top: 0;">Y-Axis (Test Method)</h3>
                        <div class="input-row">
                            <div>
                                <label class="form-label">Min Value</label>
                                <input type="number" id="yAxisMin" value="0" style="width: 90%; max-width: 120px;" />
                            </div>
                            <div>
                                <label class="form-label">Max Value</label>
                                <input type="number" id="yAxisMax" value="160" style="width: 90%; max-width: 120px;" />
                            </div>
                        </div>
                        <div class="input-row">
                            <div>
                                <label class="form-label">Interval</label>
                                <input type="number" id="yAxisInterval" value="20" min="5" style="width: 90%; max-width: 120px;" />
                            </div>
                        </div>
                        <p class="note">Smaller intervals may create crowded axis labels</p>
                    </div>
                </div>
                <button id="updateChartButton" disabled>Update Chart</button>
            </div>
            
            <div class="two-column">
                <div class="card">
                    <h2>Passing-Bablok Regression</h2>
                    <div class="chart-container" id="scatterChartContainer">
                        <canvas id="scatterChart"></canvas>
                        <div class="chart-download-container">
                            <button class="chart-download-btn">Save</button>
                            <div class="download-options" style="display: none;">
                                <div class="download-format" data-chart="scatterChart" data-format="png">PNG</div>
                                <div class="download-format" data-chart="scatterChart" data-format="jpeg">JPEG</div>
                            </div>
                        </div>
                    </div>
                    <div class="ci-selector">
                        <label for="ciSelector">Confidence Interval:</label>
                        <select id="ciSelector">
                            <option value="95">95% CI</option>
                            <option value="90">90% CI</option>
                        </select>
                    </div>
                    <div id="regressionStats" class="stats-container"></div>
                    
                    <!-- Add CUSUM plot container -->
                    <div style="margin-top: 20px;">
                        <h3>CUSUM Test for Linearity</h3>
                        <div class="chart-container example-overlay" id="cusumChartContainer" style="height: 200px;">
                            <canvas id="cusumChart"></canvas>
                            <div class="chart-download-container">
                                <button class="chart-download-btn">Save</button>
                                <div class="download-options" style="display: none;">
                                    <div class="download-format" data-chart="cusumChart" data-format="png">PNG</div>
                                    <div class="download-format" data-chart="cusumChart" data-format="jpeg">JPEG</div>
                                </div>
                            </div>
                        </div>
                        <p class="note" style="text-align: center; margin-top: 5px;">
                            This plot shows the cumulative sum of residuals. A random pattern around zero indicates linearity.
                            Systematic deviations suggest non-linearity.
                        </p>
                        
                        <!-- Add residual plot -->
                        <div class="chart-container example-overlay" id="residualChartContainer" style="height: 200px; margin-top: 15px;">
                            <canvas id="residualChart"></canvas>
                            <div class="chart-download-container">
                                <button class="chart-download-btn">Save</button>
                                <div class="download-options" style="display: none;">
                                    <div class="download-format" data-chart="residualChart" data-format="png">PNG</div>
                                    <div class="download-format" data-chart="residualChart" data-format="jpeg">JPEG</div>
                                </div>
                            </div>
                        </div>
                        <p class="note" style="text-align: center; margin-top: 5px;">
                            Residual plot shows individual residuals vs. reference method values. Random scatter around zero indicates linearity.
                            Any visible pattern suggests non-linearity.
                        </p>
                    </div>
                </div>
                
                <div class="card">
                    <h2>Bland-Altman Analysis</h2>
                    <div class="chart-container" id="blandAltmanChartContainer">
                        <canvas id="blandAltmanChart"></canvas>
                        <div class="chart-download-container">
                            <button class="chart-download-btn">Save</button>
                            <div class="download-options" style="display: none;">
                                <div class="download-format" data-chart="blandAltmanChart" data-format="png">PNG</div>
                                <div class="download-format" data-chart="blandAltmanChart" data-format="jpeg">JPEG</div>
                            </div>
                        </div>
                    </div>
                    <div class="ci-selector">
                        <label for="baCISelector">Confidence Interval:</label>
                        <select id="baCISelector">
                            <option value="95">95% CI</option>
                            <option value="90">90% CI</option>
                        </select>
                    </div>
                    <div id="blandAltmanStats" class="stats-container"></div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="exportButton" class="export-btn" disabled style="flex: 1;">Export Results as PDF</button>
                <button id="exportWordButton" class="export-btn" disabled style="flex: 1; background-color: #2563eb;">Export Results as Word</button>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const fileInput = document.getElementById('fileInput');
            const currentAnalyzerInput = document.getElementById('currentAnalyzerInput');
            const newAnalyzerInput = document.getElementById('newAnalyzerInput');
            const currentAnalyzerSelect = document.getElementById('currentAnalyzerSelect');
            const newAnalyzerSelect = document.getElementById('newAnalyzerSelect');
            const analyzeButton = document.getElementById('analyzeButton');
            const resultsContainer = document.getElementById('resultsContainer');
            const scatterChart = document.getElementById('scatterChart');
            const blandAltmanChart = document.getElementById('blandAltmanChart');
            const regressionStats = document.getElementById('regressionStats');
            const blandAltmanStats = document.getElementById('blandAltmanStats');
            const exportButton = document.getElementById('exportButton');
            const exportWordButton = document.getElementById('exportWordButton');
            const xAxisMin = document.getElementById('xAxisMin');
            const xAxisMax = document.getElementById('xAxisMax');
            const yAxisMin = document.getElementById('yAxisMin');
            const yAxisMax = document.getElementById('yAxisMax');
            const updateChartButton = document.getElementById('updateChartButton');
            const xAxisInterval = document.getElementById('xAxisInterval');
            const yAxisInterval = document.getElementById('yAxisInterval');
            const ciSelector = document.getElementById('ciSelector');
            const baCISelector = document.getElementById('baCISelector');
            
            // Chart instances
            let scatterChartInstance = null;
            let blandAltmanChartInstance = null;
            let cusumChartInstance = null;
            let residualChartInstance = null;
            
            // Data storage
            let excelData = null;
            let columns = [];
            let analysisResults = null;
            
            // Add a flag to track if we're using dummy data
            let usingDummyData = true;
            
            // Event listeners
            fileInput.addEventListener('change', handleFileUpload);
            analyzeButton.addEventListener('click', analyzeData);
            updateChartButton.addEventListener('click', updateCharts);
            exportButton.addEventListener('click', exportToPDF);
            exportWordButton.addEventListener('click', exportToWord);
            ciSelector.addEventListener('change', updateConfidenceIntervals);
            baCISelector.addEventListener('change', updateConfidenceIntervals);
            
            // Functions
            function handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        
                        // Get first sheet
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        
                        // Convert to JSON
                        excelData = XLSX.utils.sheet_to_json(worksheet);
                        console.log('Loaded Excel data:', excelData); // Debug log
                        
                        // Mark as using real data, not dummy data
                        usingDummyData = false;
                        
                        // Get column headers
                        if (excelData.length > 0) {
                            columns = Object.keys(excelData[0]);
                            console.log('Column headers:', columns); // Debug log
                            
                            // Populate select dropdowns
                            populateSelectOptions(currentAnalyzerSelect, columns);
                            populateSelectOptions(newAnalyzerSelect, columns);
                            
                            // Enable selects
                            currentAnalyzerSelect.disabled = false;
                            newAnalyzerSelect.disabled = false;
                            
                            // Allow analyze button to be enabled based on selection
                            checkAnalyzeButton();
                        }
                    } catch (error) {
                        console.error('Error processing file:', error);
                        alert('Error processing file: ' + error.message);
                    }
                };
                reader.readAsArrayBuffer(file);
            }
            
            function populateSelectOptions(selectElement, options) {
                selectElement.innerHTML = '<option value="">Select a column...</option>';
                options.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option;
                    optionElement.textContent = option;
                    selectElement.appendChild(optionElement);
                });
            }
            
            // Add function to update analyzer names based on column selection
            function updateAnalyzerNames() {
                const currentColumn = currentAnalyzerSelect.value;
                const newColumn = newAnalyzerSelect.value;
                
                if (currentColumn) {
                    currentAnalyzerInput.value = currentColumn;
                }
                
                if (newColumn) {
                    newAnalyzerInput.value = newColumn;
                }
            }
            
            // Add event listeners for column selection changes
            currentAnalyzerSelect.addEventListener('change', function() {
                updateAnalyzerNames();
                checkAnalyzeButton();
            });
            
            newAnalyzerSelect.addEventListener('change', function() {
                updateAnalyzerNames();
                checkAnalyzeButton();
            });
            
            function checkAnalyzeButton() {
                const currentSelected = currentAnalyzerSelect.value;
                const newSelected = newAnalyzerSelect.value;
                const directInputData = directDataInput.value.trim();
                
                // Enable analyze button if:
                // 1. Using direct input AND data is entered AND columns are selected
                // OR
                // 2. Using Excel upload AND columns are selected
                const hasDirectInput = directInputRadio.checked && directInputData.length > 0;
                const hasExcelData = excelInputRadio.checked && !usingDummyData;
                
                analyzeButton.disabled = !(
                    (hasDirectInput || hasExcelData) && 
                    currentSelected && 
                    newSelected && 
                    currentSelected !== newSelected
                );
            }
            
            function analyzeData() {
                if (!excelData || excelData.length === 0) {
                    alert('No data available for analysis.');
                    return;
                }

                // Get the selected columns
                const currentColumn = currentAnalyzerSelect.value;
                const newColumn = newAnalyzerSelect.value;

                // Check if columns are selected and different
                if (!currentColumn || !newColumn) {
                    alert('Please select both columns for analysis.');
                    return;
                }

                if (currentColumn === newColumn) {
                    alert('Please select different columns for analysis.');
                    return;
                }
                
                // Check if user is logged in
                window.supabaseClient.auth.getSession().then(async ({ data: { session } }) => {
                    if (!session) {
                        alert('Please log in to perform analysis.');
                        window.toggleAuthModal(true);
                        return;
                    }
                    
                    // Deduct token for analysis
                    const tokenDeducted = await deductToken();
                    if (!tokenDeducted) {
                        return; // Don't proceed if token deduction failed
                    }
                    
                    // Continue with analysis
                    performAnalysis(currentColumn, newColumn);
                }).catch(err => {
                    console.error('Error checking session:', err);
                    alert('An error occurred while checking your session. Please try again.');
                });
            }
            
            // Split out the actual analysis logic to a separate function
            function performAnalysis(currentColumn, newColumn) {
                try {
                    // Create paired data array
                    const pairedData = excelData.map(row => ({
                        current: parseFloat(row[currentColumn]),
                        new: parseFloat(row[newColumn])
                    }));

                    // Filter out any rows with missing or invalid values
                    const validData = pairedData.filter(pair => 
                        !isNaN(pair.current) && !isNaN(pair.new) && 
                        pair.current !== null && pair.new !== null
                    );

                    if (validData.length === 0) {
                        alert('No valid data pairs found for analysis.');
                        return;
                    }

                    // Calculate regression
                    const regression = calculatePassingBablok(validData);
                    
                    // Calculate Bland-Altman
                    const blandAltman = calculateBlandAltman(validData);
                    
                    // Calculate data ranges for auto-scaling
                    const currentValues = validData.map(pair => pair.current);
                    const newValues = validData.map(pair => pair.new);
                    
                    const dataRanges = {
                        xMin: Math.floor(Math.min(...currentValues)),
                        xMax: Math.ceil(Math.max(...currentValues)),
                        yMin: Math.floor(Math.min(...newValues)),
                        yMax: Math.ceil(Math.max(...newValues))
                    };
                    
                    // Store results
                    analysisResults = {
                        pairedData: validData,
                        regression,
                        blandAltman,
                        currentAnalyzerName: currentAnalyzerInput.value || 'Reference Method',
                        newAnalyzerName: newAnalyzerInput.value || 'Test Method',
                        dataRanges
                    };
                    
                    // Update input fields with auto-detected ranges
                    xAxisMin.value = dataRanges.xMin;
                    xAxisMax.value = dataRanges.xMax;
                    yAxisMin.value = dataRanges.yMin;
                    yAxisMax.value = dataRanges.yMax;
                    
                    // Remove example overlays from all sections
                    const sections = [
                        'axisConfigCard',
                        'scatterChartContainer',
                        'blandAltmanChartContainer',
                        'regressionStats',
                        'blandAltmanStats',
                        'cusumChartContainer',
                        'residualChartContainer',
                        'sampleCountCard',
                        'summarySectionCard',
                        'currentResultsCard'
                    ];
                    
                    sections.forEach(sectionId => {
                        const element = document.getElementById(sectionId);
                        if (element) {
                            element.classList.remove('example-overlay');
                        }
                    });
                    
                    // Update charts and statistics displays
                    updateCharts();
                    updateStatistics();
                    
                    // Update scatter chart with regression line
                    createScatterPlot();
                    
                    // Only disable example button if we're analyzing real data (not example data)
                    if (!usingDummyData) {
                        const exampleButton = document.querySelector('.example-button');
                        exampleButton.disabled = true;
                        exampleButton.style.opacity = '0.5';
                        exampleButton.style.cursor = 'not-allowed';
                        
                        // Enable export buttons only for real data
                        exportButton.disabled = false;
                        exportWordButton.disabled = false;
                        updateChartButton.disabled = false;
                    } else {
                        // For example data, keep export buttons disabled
                        exportButton.disabled = true;
                        exportWordButton.disabled = true;
                        updateChartButton.disabled = true;
                    }
                    
                    // Show results container
                    resultsContainer.style.display = 'block';
                    
                    // Update sample count
                    document.getElementById('totalSamplesCount').textContent = validData.length;
                    
                    // Update data range info
                    document.getElementById('dataRangeInfo').innerHTML = `
                        ${currentAnalyzerInput.value || 'Reference Method'}: ${Math.min(...currentValues).toFixed(2)} to ${Math.max(...currentValues).toFixed(2)}<br>
                        ${newAnalyzerInput.value || 'Test Method'}: ${Math.min(...newValues).toFixed(2)} to ${Math.max(...newValues).toFixed(2)}
                    `;
                    
                    // Show current analysis results summary
                    displayResults();
                    
                    // Scroll to results
                    resultsContainer.scrollIntoView({ behavior: 'smooth' });
                } catch (error) {
                    console.error('Error during analysis:', error);
                    alert('An error occurred during analysis: ' + error.message);
                }
            }
            
            function calculatePassingBablok(pairedData) {
                // Simple linear regression for now (as placeholder)
                // In a real implementation, we'd use the Passing-Bablok algorithm
                
                const n = pairedData.length;
                let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0, sumYY = 0;
                
                pairedData.forEach(pair => {
                    sumX += pair.current;
                    sumY += pair.new;
                    sumXY += pair.current * pair.new;
                    sumXX += pair.current * pair.current;
                    sumYY += pair.new * pair.new;
                });
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                // Calculate correlation coefficient (r)
                const numerator = n * sumXY - sumX * sumY;
                const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
                const r = numerator / denominator;
                
                // Calculate standard error for slope and intercept (approximate)
                const xMean = sumX / n;
                const yMean = sumY / n;
                
                // Calculate residuals and standard error
                let sumResidualSquared = 0;
                pairedData.forEach(pair => {
                    const predicted = slope * pair.current + intercept;
                    const residual = pair.new - predicted;
                    sumResidualSquared += residual * residual;
                });
                
                // Standard error of the regression
                const se = Math.sqrt(sumResidualSquared / (n - 2));
                
                // Standard error of the slope
                const slopeStdError = se / Math.sqrt(sumXX - n * xMean * xMean);
                
                // Standard error of the intercept
                const interceptStdError = se * Math.sqrt(sumXX / (n * (sumXX - n * xMean * xMean)));
                
                // Calculate t-statistics for slope and intercept
                const slopeT = Math.abs(slope - 1) / slopeStdError;
                const interceptT = Math.abs(intercept) / interceptStdError;
                
                // Calculate p-values (two-tailed test)
                // Using t-distribution with n-2 degrees of freedom
                // For large samples, we approximate with standard normal distribution
                const calculatePValue = (tValue, df) => {
                    // For large samples, approximate with standard normal distribution
                    if (df > 30) {
                        // Approximation using standard normal distribution
                        // This is a simplified calculation - in practice, use a proper statistical library
                        const z = Math.abs(tValue);
                        return 2 * (1 - normalCDF(z));
                    } else {
                        // For smaller samples, we should use t-distribution
                        // This is a very rough approximation - in practice, use a proper statistical library
                        return 2 * (1 - normalCDF(Math.abs(tValue)));
                    }
                };
                
                // Simple approximation of the standard normal CDF
                const normalCDF = (z) => {
                    // Approximation of the standard normal CDF
                    // This is a simplified calculation using error function approximation
                    const b1 = 0.31938153;
                    const b2 = -0.356563782;
                    const b3 = 1.781477937;
                    const b4 = -1.821255978;
                    const b5 = 1.330274429;
                    const p = 0.2316419;
                    const c = 0.39894228;
                    
                    if (z >= 0) {
                        const t = 1.0 / (1.0 + p * z);
                        return 1.0 - c * Math.exp(-z * z / 2.0) * t * (t * (t * (t * (t * b5 + b4) + b3) + b2) + b1);
                    } else {
                        const t = 1.0 / (1.0 - p * z);
                        return c * Math.exp(-z * z / 2.0) * t * (t * (t * (t * (t * b5 + b4) + b3) + b2) + b1);
                    }
                };
                
                const slopePValue = calculatePValue(slopeT, n - 2);
                const interceptPValue = calculatePValue(interceptT, n - 2);
                
                // Calculate confidence intervals (95% and 90%)
                // Critical t-values for different confidence levels
                // For large samples, we can approximate with z-values
                const t95 = 1.96; // 95% confidence (z-value for normal distribution)
                const t90 = 1.645; // 90% confidence
                
                // 95% Confidence intervals
                const slopeCI95Lower = slope - t95 * slopeStdError;
                const slopeCI95Upper = slope + t95 * slopeStdError;
                const interceptCI95Lower = intercept - t95 * interceptStdError;
                const interceptCI95Upper = intercept + t95 * interceptStdError;
                
                // 90% Confidence intervals
                const slopeCI90Lower = slope - t90 * slopeStdError;
                const slopeCI90Upper = slope + t90 * slopeStdError;
                const interceptCI90Lower = intercept - t90 * interceptStdError;
                const interceptCI90Upper = intercept + t90 * interceptStdError;
                
                // Calculate CUSUM test for linearity
                // Sort pairs by x value (current analyzer)
                const sortedPairs = [...pairedData].sort((a, b) => a.current - b.current);
                
                // Calculate residuals
                const residuals = sortedPairs.map(pair => {
                    const predicted = slope * pair.current + intercept;
                    return pair.new - predicted;
                });
                
                // Calculate cumulative sum of residuals
                let cusum = 0;
                const cusumValues = residuals.map(residual => {
                    cusum += residual;
                    return cusum;
                });
                
                // Calculate maximum absolute CUSUM value
                const maxCusum = Math.max(...cusumValues.map(Math.abs));
                
                // Calculate standard deviation of residuals
                const residualMean = residuals.reduce((sum, val) => sum + val, 0) / residuals.length;
                const residualVar = residuals.reduce((sum, val) => sum + Math.pow(val - residualMean, 2), 0) / (residuals.length - 1);
                const residualStdDev = Math.sqrt(residualVar);
                
                // Calculate CUSUM test statistic
                const cusumStat = maxCusum / (residualStdDev * Math.sqrt(n));
                
                // Critical values for CUSUM test (approximate)
                // These are based on the Kolmogorov-Smirnov distribution
                // For alpha = 0.05 (95% confidence)
                const cusumCritical95 = 1.358;
                
                // For alpha = 0.10 (90% confidence)
                const cusumCritical90 = 1.224;
                
                // Calculate CUSUM p-value (approximate)
                // Using the asymptotic distribution of the Kolmogorov-Smirnov statistic
                const cusumPValue = Math.exp(-2 * cusumStat * cusumStat);
                
                // Save indices for original order
                const sortedIndices = sortedPairs.map((_, i) => i);
                
                return {
                    slope,
                    intercept,
                    equation: `y = ${slope.toFixed(2)}x + ${intercept.toFixed(2)}`,
                    r,
                    slopeStdError,
                    interceptStdError,
                    slopeT,
                    interceptT,
                    slopePValue,
                    interceptPValue,
                    confidenceIntervals: {
                        slope95: {
                            lower: slopeCI95Lower,
                            upper: slopeCI95Upper
                        },
                        intercept95: {
                            lower: interceptCI95Lower,
                            upper: interceptCI95Upper
                        },
                        slope90: {
                            lower: slopeCI90Lower,
                            upper: slopeCI90Upper
                        },
                        intercept90: {
                            lower: interceptCI90Lower,
                            upper: interceptCI90Upper
                        }
                    },
                    cusum: {
                        statistic: cusumStat,
                        critical95: cusumCritical95,
                        critical90: cusumCritical90,
                        pValue: cusumPValue,
                        values: cusumValues,
                        residuals: residuals,
                        xValues: sortedPairs.map(pair => pair.current),
                        sortedIndices: sortedIndices
                    }
                };
            }
            
            function calculateBlandAltman(pairedData) {
                const differences = pairedData.map(pair => pair.new - pair.current);
                const means = pairedData.map(pair => (pair.new + pair.current) / 2);
                
                // Calculate mean difference (bias)
                const meanDiff = differences.reduce((sum, diff) => sum + diff, 0) / differences.length;
                
                // Calculate standard deviation of differences
                const sumSquaredDiffs = differences.reduce((sum, diff) => sum + Math.pow(diff - meanDiff, 2), 0);
                const stdDev = Math.sqrt(sumSquaredDiffs / (differences.length - 1));
                
                // Calculate standard error of bias
                const seBias = stdDev / Math.sqrt(differences.length);
                
                // Calculate standard error of limits of agreement
                const seLimits = Math.sqrt((3 * stdDev * stdDev) / differences.length);
                
                // Critical values for confidence intervals
                const z95 = 1.96;
                const z90 = 1.645;
                
                // 95% Confidence intervals for bias
                const bias95LowerCI = meanDiff - z95 * seBias;
                const bias95UpperCI = meanDiff + z95 * seBias;
                
                // 90% Confidence intervals for bias
                const bias90LowerCI = meanDiff - z90 * seBias;
                const bias90UpperCI = meanDiff + z90 * seBias;
                
                // Calculate 95% limits of agreement
                const upperLimit95 = meanDiff + 1.96 * stdDev;
                const lowerLimit95 = meanDiff - 1.96 * stdDev;
                
                // Calculate 90% limits of agreement
                const upperLimit90 = meanDiff + 1.645 * stdDev;
                const lowerLimit90 = meanDiff - 1.645 * stdDev;
                
                // 95% Confidence intervals for limits of agreement
                const upperLimit95LowerCI = upperLimit95 - z95 * seLimits;
                const upperLimit95UpperCI = upperLimit95 + z95 * seLimits;
                const lowerLimit95LowerCI = lowerLimit95 - z95 * seLimits;
                const lowerLimit95UpperCI = lowerLimit95 + z95 * seLimits;
                
                // 90% Confidence intervals for limits of agreement
                const upperLimit90LowerCI = upperLimit90 - z90 * seLimits;
                const upperLimit90UpperCI = upperLimit90 + z90 * seLimits;
                const lowerLimit90LowerCI = lowerLimit90 - z90 * seLimits;
                const lowerLimit90UpperCI = lowerLimit90 + z90 * seLimits;
                
                return {
                    means,
                    differences,
                    meanDiff,
                    stdDev,
                    seBias,
                    seLimits,
                    limits95: {
                        upper: upperLimit95,
                        lower: lowerLimit95,
                        upperCI: {
                            lower: upperLimit95LowerCI,
                            upper: upperLimit95UpperCI
                        },
                        lowerCI: {
                            lower: lowerLimit95LowerCI,
                            upper: lowerLimit95UpperCI
                        },
                        biasCI: {
                            lower: bias95LowerCI,
                            upper: bias95UpperCI
                        }
                    },
                    limits90: {
                        upper: upperLimit90,
                        lower: lowerLimit90,
                        upperCI: {
                            lower: upperLimit90LowerCI,
                            upper: upperLimit90UpperCI
                        },
                        lowerCI: {
                            lower: lowerLimit90LowerCI,
                            upper: lowerLimit90UpperCI
                        },
                        biasCI: {
                            lower: bias90LowerCI,
                            upper: bias90UpperCI
                        }
                    }
                };
            }
            
            function displayResults() {
                if (!analysisResults) return;
                
                // Update sample count display
                const totalSamplesCount = document.getElementById('totalSamplesCount');
                const dataRangeInfo = document.getElementById('dataRangeInfo');
                
                totalSamplesCount.textContent = analysisResults.pairedData.length;
                
                const currentValues = analysisResults.pairedData.map(pair => pair.current);
                const newValues = analysisResults.pairedData.map(pair => pair.new);
                const minCurrent = Math.min(...currentValues).toFixed(2);
                const maxCurrent = Math.max(...currentValues).toFixed(2);
                const minNew = Math.min(...newValues).toFixed(2);
                const maxNew = Math.max(...newValues).toFixed(2);
                
                dataRangeInfo.innerHTML = `
                    <strong>${analysisResults.currentAnalyzerName}:</strong> ${minCurrent} - ${maxCurrent}<br>
                    <strong>${analysisResults.newAnalyzerName}:</strong> ${minNew} - ${maxNew}
                `;
                
                // Get regression results for interpretation
                const slope = analysisResults.regression.slope;
                const intercept = analysisResults.regression.intercept;
                const r = analysisResults.regression.r;
                const slopeRounded = slope.toFixed(4);
                const interceptRounded = intercept.toFixed(4);
                const rRounded = r.toFixed(4);
                
                // Get p-values
                const slopePValue = analysisResults.regression.slopePValue.toFixed(4);
                const interceptPValue = analysisResults.regression.interceptPValue.toFixed(4);
                
                // Get CUSUM test results
                const cusumStat = analysisResults.regression.cusum.statistic.toFixed(4);
                const cusumPValue = analysisResults.regression.cusum.pValue.toFixed(4);
                const cusumCritical95 = analysisResults.regression.cusum.critical95.toFixed(4);
                
                // Get selected confidence interval level for Passing-Bablok
                const selectedCI = ciSelector.value;
                
                // Get confidence intervals based on selection
                const ciLevel = selectedCI === '95' ? '95' : '90';
                const ciLevelDisplay = selectedCI === '95' ? '95%' : '90%';
                
                const slopeCILower = analysisResults.regression.confidenceIntervals[`slope${ciLevel}`].lower.toFixed(4);
                const slopeCIUpper = analysisResults.regression.confidenceIntervals[`slope${ciLevel}`].upper.toFixed(4);
                const interceptCILower = analysisResults.regression.confidenceIntervals[`intercept${ciLevel}`].lower.toFixed(4);
                const interceptCIUpper = analysisResults.regression.confidenceIntervals[`intercept${ciLevel}`].upper.toFixed(4);
                
                // Interpret Passing-Bablok regression
                let slopeInterpretation = '';
                if (Math.abs(slope - 1) < 0.05) {
                    slopeInterpretation = 'The slope is very close to 1, suggesting no proportional difference between the methods.';
                } else if (slope > 1) {
                    slopeInterpretation = `The slope is greater than 1 (${slopeRounded}), indicating that the ${analysisResults.newAnalyzerName} gives proportionally higher values than the ${analysisResults.currentAnalyzerName} as the concentration increases.`;
                } else {
                    slopeInterpretation = `The slope is less than 1 (${slopeRounded}), indicating that the ${analysisResults.newAnalyzerName} gives proportionally lower values than the ${analysisResults.currentAnalyzerName} as the concentration increases.`;
                }
                
                // Add p-value interpretation for slope
                let slopePValueInterpretation = '';
                if (parseFloat(slopePValue) < 0.05) {
                    slopePValueInterpretation = `The p-value for slope (${slopePValue}) is less than 0.05, indicating that the slope is significantly different from 1.`;
                } else {
                    slopePValueInterpretation = `The p-value for slope (${slopePValue}) is greater than 0.05, indicating that the slope is not significantly different from 1.`;
                }
                
                // Add confidence interval interpretation
                let ciInterpretation = '';
                if (analysisResults.regression.confidenceIntervals[`slope${ciLevel}`].lower <= 1 && 
                    analysisResults.regression.confidenceIntervals[`slope${ciLevel}`].upper >= 1) {
                    ciInterpretation = `The ${ciLevelDisplay} confidence interval for the slope (${slopeCILower} to ${slopeCIUpper}) includes 1, suggesting that there might not be a significant proportional difference between the methods.`;
                } else {
                    ciInterpretation = `The ${ciLevelDisplay} confidence interval for the slope (${slopeCILower} to ${slopeCIUpper}) does not include 1, confirming a significant proportional difference between the methods.`;
                }
                
                let interceptInterpretation = '';
                if (Math.abs(intercept) < 1) {
                    interceptInterpretation = 'The intercept is very close to 0, suggesting no systematic constant difference between the methods.';
                } else if (intercept > 0) {
                    interceptInterpretation = `The positive intercept (${interceptRounded}) suggests that the ${analysisResults.newAnalyzerName} has a constant positive bias relative to the ${analysisResults.currentAnalyzerName}.`;
                } else {
                    interceptInterpretation = `The negative intercept (${interceptRounded}) suggests that the ${analysisResults.newAnalyzerName} has a constant negative bias relative to the ${analysisResults.currentAnalyzerName}.`;
                }
                
                // Add p-value interpretation for intercept
                let interceptPValueInterpretation = '';
                if (parseFloat(interceptPValue) < 0.05) {
                    interceptPValueInterpretation = `The p-value for intercept (${interceptPValue}) is less than 0.05, indicating that the intercept is significantly different from 0.`;
                } else {
                    interceptPValueInterpretation = `The p-value for intercept (${interceptPValue}) is greater than 0.05, indicating that the intercept is not significantly different from 0.`;
                }
                
                // Add intercept confidence interval interpretation
                let interceptCIInterpretation = '';
                if (analysisResults.regression.confidenceIntervals[`intercept${ciLevel}`].lower <= 0 && 
                    analysisResults.regression.confidenceIntervals[`intercept${ciLevel}`].upper >= 0) {
                    interceptCIInterpretation = `The ${ciLevelDisplay} confidence interval for the intercept (${interceptCILower} to ${interceptCIUpper}) includes 0, suggesting that there might not be a significant constant difference between the methods.`;
                } else {
                    interceptCIInterpretation = `The ${ciLevelDisplay} confidence interval for the intercept (${interceptCILower} to ${interceptCIUpper}) does not include 0, confirming a significant constant difference between the methods.`;
                }
                
                // Add CUSUM test interpretation
                let cusumInterpretation = '';
                if (parseFloat(cusumPValue) < 0.05) {
                    cusumInterpretation = `The CUSUM test p-value (${cusumPValue}) is less than 0.05, suggesting that the relationship between the methods may not be linear. Non-linearity could indicate concentration-dependent differences that the Passing-Bablok regression assumptions do not account for.`;
                } else {
                    cusumInterpretation = `The CUSUM test p-value (${cusumPValue}) is greater than 0.05, supporting the assumption of linearity in the relationship between the methods. This validates the use of Passing-Bablok regression for this comparison.`;
                }
                
                // Interpret correlation coefficient
                let correlationInterpretation = '';
                if (Math.abs(r) > 0.95) {
                    correlationInterpretation = `The correlation coefficient is very strong (${rRounded}), indicating excellent linear relationship between the two methods.`;
                } else if (Math.abs(r) > 0.9) {
                    correlationInterpretation = `The correlation coefficient is strong (${rRounded}), indicating good linear relationship between the two methods.`;
                } else if (Math.abs(r) > 0.7) {
                    correlationInterpretation = `The correlation coefficient is moderate (${rRounded}), indicating moderate linear relationship between the two methods.`;
                } else {
                    correlationInterpretation = `The correlation coefficient is weak (${rRounded}), indicating poor linear relationship between the two methods.`;
                }
                
                // Get Bland-Altman results for interpretation
                // Get selected confidence interval level for Bland-Altman
                const baCILevel = baCISelector.value;
                const baLevel = baCILevel === '95' ? '95' : '90';
                const baLevelDisplay = baCILevel === '95' ? '95%' : '90%';
                
                const bias = analysisResults.blandAltman.meanDiff;
                const upperLimit = analysisResults.blandAltman[`limits${baLevel}`].upper;
                const lowerLimit = analysisResults.blandAltman[`limits${baLevel}`].lower;
                
                // Get confidence intervals for bias and limits
                const biasLowerCI = analysisResults.blandAltman[`limits${baLevel}`].biasCI.lower.toFixed(4);
                const biasUpperCI = analysisResults.blandAltman[`limits${baLevel}`].biasCI.upper.toFixed(4);
                const upperLimitLowerCI = analysisResults.blandAltman[`limits${baLevel}`].upperCI.lower.toFixed(4);
                const upperLimitUpperCI = analysisResults.blandAltman[`limits${baLevel}`].upperCI.upper.toFixed(4);
                const lowerLimitLowerCI = analysisResults.blandAltman[`limits${baLevel}`].lowerCI.lower.toFixed(4);
                const lowerLimitUpperCI = analysisResults.blandAltman[`limits${baLevel}`].lowerCI.upper.toFixed(4);
                
                const biasRounded = bias.toFixed(4);
                const upperLimitRounded = upperLimit.toFixed(4);
                const lowerLimitRounded = lowerLimit.toFixed(4);
                const range = upperLimit - lowerLimit;
                
                // Update the "Current Results Summary" section
                const currentResultsSummary = document.getElementById('currentResultsSummary');
                currentResultsSummary.innerHTML = `
                    <h3>Current Analysis Results</h3>
                    <p style="color: #666; font-style: italic;">Below are the key values from your current analysis:</p>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                        <div>
                            <h4>Passing-Bablok Regression</h4>
                            <ul style="list-style-type: none; padding-left: 0;">
                                <li><strong>Slope:</strong> ${slopeRounded} (${ciLevelDisplay} CI: ${slopeCILower} to ${slopeCIUpper})</li>
                                <li><strong>p-value (Slope≠1):</strong> ${slopePValue}</li>
                                <li><strong>Intercept:</strong> ${interceptRounded} (${ciLevelDisplay} CI: ${interceptCILower} to ${interceptCIUpper})</li>
                                <li><strong>p-value (Intercept≠0):</strong> ${interceptPValue}</li>
                                <li><strong>Correlation (r):</strong> ${rRounded}</li>
                                <li><strong>CUSUM Test p-value:</strong> ${cusumPValue}</li>
                            </ul>
                        </div>
                        <div>
                            <h4>Bland-Altman Analysis</h4>
                            <ul style="list-style-type: none; padding-left: 0;">
                                <li><strong>Mean Bias:</strong> ${biasRounded} (${baLevelDisplay} CI: ${biasLowerCI} to ${biasUpperCI})</li>
                                <li><strong>Limits of Agreement:</strong></li>
                                <li>- Upper: ${upperLimitRounded} (${baLevelDisplay} CI: ${upperLimitLowerCI} to ${upperLimitUpperCI})</li>
                                <li>- Lower: ${lowerLimitRounded} (${baLevelDisplay} CI: ${lowerLimitLowerCI} to ${lowerLimitUpperCI})</li>
                            </ul>
                        </div>
                    </div>
                    <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd;">
                        <button class="smart-interpretation-btn" style="background-color: #3b82f6; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; width: 100%; text-align: center; margin-bottom: 15px;">Show Agreement Assessment</button>
                        <div class="interpretation-content" style="display: none;">
                        <p><strong>Agreement Assessment:</strong> ${
                            (Math.abs(slope - 1) < 0.1 && 
                             Math.abs(intercept) < 2 && 
                             Math.abs(r) > 0.95 && 
                             parseFloat(slopePValue) >= 0.05 && 
                             parseFloat(interceptPValue) >= 0.05 && 
                             parseFloat(cusumPValue) >= 0.05 &&
                             Math.abs(bias) < 2) 
                            ? 'Methods show excellent agreement with no significant bias and verified linearity.' 
                            : (Math.abs(slope - 1) < 0.2 && 
                               Math.abs(intercept) < 5 && 
                               Math.abs(r) > 0.9 && 
                               Math.abs(bias) < 5)
                              ? 'Methods show good agreement with minor bias.' 
                              : 'Methods show differences that may require clinical evaluation.'
                        }</p>
                        </div>
                    </div>
                `;
                
                // Display regression stats with interpretation
                regressionStats.innerHTML = `
                    <div>
                        <h3>Statistical Results</h3>
                        <p><strong>Regression Equation:</strong> ${analysisResults.regression.equation}</p>
                        <p><strong>Slope:</strong> ${slopeRounded}</p>
                        <p><strong>p-value (Slope≠1):</strong> ${slopePValue}</p>
                        <p><strong>${ciLevelDisplay} CI for Slope:</strong> ${slopeCILower} to ${slopeCIUpper}</p>
                        <p><strong>Intercept:</strong> ${interceptRounded}</p>
                        <p><strong>p-value (Intercept≠0):</strong> ${interceptPValue}</p>
                        <p><strong>${ciLevelDisplay} CI for Intercept:</strong> ${interceptCILower} to ${interceptCIUpper}</p>
                        <p><strong>Correlation Coefficient (r):</strong> ${rRounded}</p>
                        <p><strong>CUSUM Test for Linearity:</strong></p>
                        <p style="margin-left: 15px;"><strong>Statistic:</strong> ${cusumStat} (Critical value at 95%: ${cusumCritical95})</p>
                        <p style="margin-left: 15px;"><strong>p-value:</strong> ${cusumPValue} ${parseFloat(cusumPValue) >= 0.05 ? '(Linearity supported)' : '(Non-linearity detected)'}</p>
                    </div>
                    <div class="interpretation-container" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                        <button class="smart-interpretation-btn" style="background-color: #3b82f6; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; width: 100%; text-align: center; margin-bottom: 15px;">Show Smart Interpretation</button>
                        <div class="interpretation-content" style="display: none;">
                        <h3>Interpretation</h3>
                        <p>${slopeInterpretation}</p>
                        <p>${slopePValueInterpretation}</p>
                        <p>${ciInterpretation}</p>
                        <p>${interceptInterpretation}</p>
                        <p>${interceptPValueInterpretation}</p>
                        <p>${interceptCIInterpretation}</p>
                        <p>${correlationInterpretation}</p>
                        <p>${cusumInterpretation}</p>
                        <p><strong>Summary:</strong> ${
                            Math.abs(slope - 1) < 0.05 && 
                            Math.abs(intercept) < 1 && 
                            Math.abs(r) > 0.9 && 
                            parseFloat(cusumPValue) >= 0.05 ? 
                            `The methods appear to be in good agreement with no significant systematic differences, strong correlation, and confirmed linearity.` : 
                            `There are ${Math.abs(slope - 1) < 0.05 ? 'no proportional' : 'proportional'} and ${Math.abs(intercept) < 1 ? 'no constant' : 'constant'} differences between the methods, with ${Math.abs(r) > 0.9 ? 'strong' : Math.abs(r) > 0.7 ? 'moderate' : 'weak'} correlation${parseFloat(cusumPValue) < 0.05 ? ' and potential non-linearity in the relationship' : ''}.`
                        }</p>
                        </div>
                    </div>
                `;
                
                // Interpret Bland-Altman results
                let biasInterpretation = '';
                if (Math.abs(bias) < 2) {
                    biasInterpretation = `The mean difference (bias) of ${biasRounded} is close to zero, suggesting good overall agreement between the methods.`;
                } else if (bias > 0) {
                    biasInterpretation = `The positive mean difference (bias) of ${biasRounded} indicates that the ${analysisResults.newAnalyzerName} tends to give higher results than the ${analysisResults.currentAnalyzerName}.`;
                } else {
                    biasInterpretation = `The negative mean difference (bias) of ${biasRounded} indicates that the ${analysisResults.newAnalyzerName} tends to give lower results than the ${analysisResults.currentAnalyzerName}.`;
                }
                
                // Add bias confidence interval interpretation
                let biasCIInterpretation = '';
                if (parseFloat(biasLowerCI) <= 0 && parseFloat(biasUpperCI) >= 0) {
                    biasCIInterpretation = `The ${baLevelDisplay} confidence interval for the bias (${biasLowerCI} to ${biasUpperCI}) includes 0, suggesting the bias may not be statistically significant.`;
                } else {
                    biasCIInterpretation = `The ${baLevelDisplay} confidence interval for the bias (${biasLowerCI} to ${biasUpperCI}) does not include 0, confirming a statistically significant bias.`;
                }
                
                let agreementInterpretation = '';
                if (range < 10) {
                    agreementInterpretation = `The limits of agreement (${lowerLimitRounded} to ${upperLimitRounded}) are relatively narrow, indicating good agreement between the methods.`;
                } else if (range < 20) {
                    agreementInterpretation = `The limits of agreement (${lowerLimitRounded} to ${upperLimitRounded}) indicate moderate agreement between the methods.`;
                } else {
                    agreementInterpretation = `The limits of agreement (${lowerLimitRounded} to ${upperLimitRounded}) are wide, suggesting considerable variability between the methods.`;
                }
                
                // Display Bland-Altman stats with interpretation
                blandAltmanStats.innerHTML = `
                    <div>
                        <h3>Statistical Results</h3>
                        <p><strong>Mean Difference (Bias):</strong> ${biasRounded}</p>
                        <p><strong>${baLevelDisplay} CI for Bias:</strong> ${biasLowerCI} to ${biasUpperCI}</p>
                        <p><strong>Standard Deviation:</strong> ${analysisResults.blandAltman.stdDev.toFixed(4)}</p>
                        <p><strong>Upper Limit of Agreement (Bias + ${baLevel === '95' ? '1.96' : '1.645'} SD):</strong> ${upperLimitRounded}</p>
                        <p><strong>${baLevelDisplay} CI for Upper Limit:</strong> ${upperLimitLowerCI} to ${upperLimitUpperCI}</p>
                        <p><strong>Lower Limit of Agreement (Bias - ${baLevel === '95' ? '1.96' : '1.645'} SD):</strong> ${lowerLimitRounded}</p>
                        <p><strong>${baLevelDisplay} CI for Lower Limit:</strong> ${lowerLimitLowerCI} to ${lowerLimitUpperCI}</p>
                    </div>
                    <div class="interpretation-container" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                        <button class="smart-interpretation-btn" style="background-color: #3b82f6; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; width: 100%; text-align: center; margin-bottom: 15px;">Show Smart Interpretation</button>
                        <div class="interpretation-content" style="display: none;">
                        <h3>Interpretation</h3>
                        <p>${biasInterpretation}</p>
                        <p>${biasCIInterpretation}</p>
                        <p>${agreementInterpretation}</p>
                        <p><strong>Clinical Relevance:</strong> ${Math.abs(bias) < 5 && range < 20 ? 
                            `The differences between methods are likely not clinically significant.` : 
                            `The differences between methods may be clinically significant and should be evaluated in the context of clinical decision limits.`}
                        </p>
                        </div>
                    </div>
                `;
                
                // Add event listeners to smart interpretation buttons
                document.querySelectorAll('.smart-interpretation-btn').forEach(button => {
                    button.addEventListener('click', function() {
                        // Toggle visibility of the content
                        const content = this.nextElementSibling;
                        const isHidden = content.style.display === 'none';
                        
                        // Show/hide content
                        content.style.display = isHidden ? 'block' : 'none';
                        
                        // Update button text
                        this.textContent = isHidden ? 'Hide Smart Interpretation' : 'Show Smart Interpretation';
                        
                        // Add notice for dummy data
                        if (usingDummyData && isHidden && content.querySelector('.dummy-data-notice') === null) {
                            const notice = document.createElement('div');
                            notice.className = 'dummy-data-notice';
                            notice.style.backgroundColor = '#fff3cd';
                            notice.style.color = '#856404';
                            notice.style.padding = '10px';
                            notice.style.borderRadius = '4px';
                            notice.style.marginBottom = '15px';
                            notice.innerHTML = '<strong>Note:</strong> You are viewing interpretation of example data. Upload your own Excel file to see actual interpretation of your data.';
                            content.insertBefore(notice, content.firstChild);
                        }
                    });
                });
                
                // Draw charts
                drawCharts();
            }
            
            function getChartOptions(title, xAxisLabel, yAxisLabel, xMin, xMax, yMin, yMax, xInterval, yInterval) {
                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: title,
                            font: {
                                size: 18
                            }
                        },
                        legend: {
                            position: 'top'
                        },
                        watermark: {
                            image: usingDummyData ? createExampleWatermark() : null
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: xAxisLabel
                            },
                            min: xMin,
                            max: xMax,
                            ticks: {
                                stepSize: xInterval
                            },
                            beginAtZero: true
                        },
                        y: {
                            title: {
                                display: true,
                                text: yAxisLabel
                            },
                            min: yMin,
                            max: yMax,
                            ticks: {
                                stepSize: yInterval
                            },
                            beginAtZero: true
                        }
                    }
                };
            }
            
            function drawCharts() {
                if (!analysisResults) return;
                
                // Get user-defined values and ALWAYS respect them
                // Always prefer the user input values - never override them with auto-detected values
                const xMin = !isNaN(parseInt(xAxisMin.value)) ? parseInt(xAxisMin.value) : analysisResults.dataRanges.xMin;
                const xMax = !isNaN(parseInt(xAxisMax.value)) ? parseInt(xAxisMax.value) : analysisResults.dataRanges.xMax;
                const yMin = !isNaN(parseInt(yAxisMin.value)) ? parseInt(yAxisMin.value) : analysisResults.dataRanges.yMin;
                const yMax = !isNaN(parseInt(yAxisMax.value)) ? parseInt(yAxisMax.value) : analysisResults.dataRanges.yMax;
                const xInterval = !isNaN(parseInt(xAxisInterval.value)) ? parseInt(xAxisInterval.value) : 20;
                const yInterval = !isNaN(parseInt(yAxisInterval.value)) ? parseInt(yAxisInterval.value) : 20;
                
                // Draw scatter plot
                drawScatterPlot(xMin, xMax, yMin, yMax, xInterval, yInterval);
                
                // Draw Bland-Altman plot
                drawBlandAltmanPlot();
                
                // Draw CUSUM plot
                drawCusumPlot();
                
                // Draw Residual plot
                drawResidualPlot();
            }
            
            function drawScatterPlot(xMin, xMax, yMin, yMax, xInterval, yInterval) {
                try {
                    // Clear previous chart if exists
                    if (scatterChartInstance) {
                        scatterChartInstance.destroy();
                        scatterChartInstance = null;
                    }
                    
                    // Ensure we have valid data
                    if (!analysisResults || !analysisResults.pairedData || analysisResults.pairedData.length === 0) {
                        console.error('No valid data for scatter plot');
                        return;
                    }
                    
                    // Ensure axis ranges are valid numbers
                    // Always use the exact values provided by the user
                    xMin = Number.isNaN(parseFloat(xMin)) ? 0 : parseFloat(xMin);
                    xMax = Number.isNaN(parseFloat(xMax)) ? 100 : parseFloat(xMax);
                    yMin = Number.isNaN(parseFloat(yMin)) ? 0 : parseFloat(yMin);
                    yMax = Number.isNaN(parseFloat(yMax)) ? 100 : parseFloat(yMax);
                    xInterval = parseFloat(xInterval) || 20;
                    yInterval = parseFloat(yInterval) || 20;
                    
                    // Make sure min is less than max
                    if (xMin >= xMax) xMax = xMin + 100;
                    if (yMin >= yMax) yMax = yMin + 100;
                    
                    console.log('Using exact user-defined ranges:', {xMin, xMax, yMin, yMax, xInterval, yInterval});
                    
                    // Create scatter plot data
                    const scatterData = {
                        datasets: [
                            {
                                label: 'Data Points',
                                data: analysisResults.pairedData.map(pair => ({
                                    x: pair.current,
                                    y: pair.new
                                })),
                                backgroundColor: 'rgba(54, 162, 235, 0.8)',
                                pointRadius: 5,
                                pointHoverRadius: 7
                            },
                            {
                                label: 'Regression Line',
                                data: [
                                    { x: xMin, y: analysisResults.regression.slope * xMin + analysisResults.regression.intercept },
                                    { x: xMax, y: analysisResults.regression.slope * xMax + analysisResults.regression.intercept }
                                ],
                                borderColor: 'rgba(255, 99, 132, 1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                type: 'line',
                                fill: false
                            },
                            {
                                label: 'Identity Line',
                                data: [
                                    { x: xMin, y: xMin },
                                    { x: xMax, y: xMax }
                                ],
                                borderColor: 'rgba(128, 128, 128, 0.7)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                type: 'line',
                                fill: false
                            }
                        ]
                    };
                    
                    // Create chart options
                    const scatterOptions = getChartOptions('Passing-Bablok Regression', analysisResults.currentAnalyzerName, analysisResults.newAnalyzerName, xMin, xMax, yMin, yMax, xInterval, yInterval);
                    
                    console.log('Creating scatter chart with data:', scatterData); // Debug log
                    
                    // Create chart
                    scatterChartInstance = new Chart(scatterChart, {
                        type: 'scatter',
                        data: scatterData,
                        options: scatterOptions
                    });
                } catch (error) {
                    console.error('Error creating scatter plot:', error);
                }
            }
            
            function drawBlandAltmanPlot() {
                try {
                    // Clear previous chart if exists
                    if (blandAltmanChartInstance) {
                        blandAltmanChartInstance.destroy();
                        blandAltmanChartInstance = null;
                    }
                    
                    // Ensure we have valid data
                    if (!analysisResults || !analysisResults.blandAltman) {
                        console.error('No valid data for Bland-Altman plot');
                        return;
                    }
                    
                    // Get selected confidence interval level
                    const selectedCI = baCISelector.value;
                    const ciLevel = selectedCI === '95' ? '95' : '90';
                    
                    // Get data with appropriate confidence interval
                    const { means, differences, meanDiff } = analysisResults.blandAltman;
                    const limits = analysisResults.blandAltman[`limits${ciLevel}`];
                    const upperLimit = limits.upper;
                    const lowerLimit = limits.lower;
                    
                    if (!means || means.length === 0) {
                        console.error('Empty means array in Bland-Altman data');
                        return;
                    }
                    
                    // Find min and max for x-axis (means)
                    const minMean = Math.min(...means);
                    const maxMean = Math.max(...means);
                    const xRange = maxMean - minMean;
                    const xMin = Math.max(0, minMean - xRange * 0.1);
                    const xMax = maxMean + xRange * 0.1;
                    
                    // Find min and max for y-axis (differences)
                    const minDiff = Math.min(...differences);
                    const maxDiff = Math.max(...differences);
                    const yRange = Math.max(maxDiff - minDiff, Math.abs(upperLimit - lowerLimit) * 1.2);
                    const yMin = Math.min(minDiff, lowerLimit) - yRange * 0.1;
                    const yMax = Math.max(maxDiff, upperLimit) + yRange * 0.1;
                    
                    console.log('Bland-Altman ranges:', {xMin, xMax, yMin, yMax}); // Debug log
                    
                    // Create Bland-Altman plot data
                    const baData = {
                        datasets: [
                            {
                                label: 'Difference',
                                data: means.map((mean, i) => ({
                                    x: mean,
                                    y: differences[i]
                                })),
                                backgroundColor: 'rgba(54, 162, 235, 0.8)',
                                pointRadius: 5,
                                pointHoverRadius: 7
                            },
                            {
                                label: 'Mean Difference (Bias)',
                                data: [
                                    { x: xMin, y: meanDiff },
                                    { x: xMax, y: meanDiff }
                                ],
                                borderColor: 'rgba(255, 99, 132, 1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                type: 'line',
                                fill: false
                            },
                            {
                                label: 'Upper Limit of Agreement',
                                data: [
                                    { x: xMin, y: upperLimit },
                                    { x: xMax, y: upperLimit }
                                ],
                                borderColor: 'rgba(255, 99, 132, 0.7)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                type: 'line',
                                fill: false
                            },
                            {
                                label: 'Lower Limit of Agreement',
                                data: [
                                    { x: xMin, y: lowerLimit },
                                    { x: xMax, y: lowerLimit }
                                ],
                                borderColor: 'rgba(255, 99, 132, 0.7)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                type: 'line',
                                fill: false
                            }
                        ]
                    };
                    
                    console.log('Creating Bland-Altman chart with data:', baData); // Debug log
                    
                    // Create chart options with simplified axis titles
                    const baOptions = getChartOptions('Bland-Altman Plot', 'Mean', 'Difference', xMin, xMax, yMin, yMax, 20, 20);
                    
                    // Create chart
                    blandAltmanChartInstance = new Chart(blandAltmanChart, {
                        type: 'scatter',
                        data: baData,
                        options: baOptions
                    });
                } catch (error) {
                    console.error('Error creating Bland-Altman plot:', error);
                }
            }
            
            // Add a new function to draw the CUSUM plot
            function drawCusumPlot() {
                try {
                    // Clear previous chart if exists
                    if (cusumChartInstance) {
                        cusumChartInstance.destroy();
                        cusumChartInstance = null;
                    }
                    
                    // Ensure we have valid data
                    if (!analysisResults || !analysisResults.regression || !analysisResults.regression.cusum) {
                        console.error('No valid data for CUSUM plot');
                        return;
                    }
                    
                    const cusumData = analysisResults.regression.cusum;
                    const cusumValues = cusumData.values;
                    
                    if (!cusumValues || cusumValues.length === 0) {
                        console.error('Empty CUSUM data');
                        return;
                    }
                    
                    // Create array of evenly spaced indices for x-axis
                    const indices = Array.from({length: cusumValues.length}, (_, i) => i + 1);
                    
                    // Find min and max for y-axis
                    const maxAbsCusum = Math.max(...cusumValues.map(Math.abs));
                    const yRange = maxAbsCusum * 1.2;
                    
                    // Create chart options
                    const cusumOptions = {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Cumulative Sum of Residuals'
                                },
                                min: -yRange,
                                max: yRange,
                                grid: {
                                    color: function(context) {
                                        return context.tick.value === 0 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                    },
                                    lineWidth: function(context) {
                                        return context.tick.value === 0 ? 2 : 1;
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Observation Number (Ordered by Reference Value)'
                                },
                                ticks: {
                                    callback: function(value, index) {
                                        // Show fewer tick labels for readability
                                        const totalPoints = cusumValues.length;
                                        if (totalPoints <= 20 || index === 0 || index === totalPoints - 1 || index % Math.ceil(totalPoints / 10) === 0) {
                                            return value;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        const index = context[0].dataIndex;
                                        const xValue = cusumData.xValues[index];
                                        return `Observation ${index + 1} (Reference Value: ${xValue.toFixed(1)})`;
                                    },
                                    label: function(context) {
                                        return `CUSUM: ${context.raw.toFixed(2)}`;
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: 'CUSUM Plot for Linearity Assessment',
                                font: {
                                    size: 14
                                }
                            },
                            watermark: {
                                image: usingDummyData ? createExampleWatermark() : null
                            }
                        }
                    };
                    
                    // Create CUSUM plot data
                    const cusumChartData = {
                        labels: indices,
                        datasets: [
                            {
                                type: 'line',
                                label: 'CUSUM',
                                data: cusumValues,
                                fill: false,
                                borderColor: 'rgba(75, 192, 192, 1)',
                                borderWidth: 2,
                                pointBackgroundColor: 'rgba(75, 192, 192, 1)',
                                pointRadius: 3,
                                pointHoverRadius: 6,
                                tension: 0.1
                            },
                            {
                                type: 'line',
                                label: 'Zero Line',
                                data: Array(cusumValues.length).fill(0),
                                fill: false,
                                borderColor: 'rgba(128, 128, 128, 0.7)',
                                borderWidth: 1,
                                borderDash: [5, 5],
                                pointRadius: 0
                            }
                        ]
                    };
                    
                    // Create the Canvas element
                    const cusumChart = document.getElementById('cusumChart');
                    
                    // Create chart
                    cusumChartInstance = new Chart(cusumChart, {
                        type: 'line',
                        data: cusumChartData,
                        options: cusumOptions
                    });
                    
                    console.log('CUSUM chart created');
                } catch (error) {
                    console.error('Error creating CUSUM plot:', error);
                }
            }
            
            // Add a function to draw the residual plot
            function drawResidualPlot() {
                try {
                    // Clear previous chart if exists
                    if (residualChartInstance) {
                        residualChartInstance.destroy();
                        residualChartInstance = null;
                    }
                    
                    // Ensure we have valid data
                    if (!analysisResults || !analysisResults.regression || !analysisResults.regression.cusum) {
                        console.error('No valid data for residual plot');
                        return;
                    }
                    
                    const cusumData = analysisResults.regression.cusum;
                    const xValues = cusumData.xValues;
                    const residuals = cusumData.residuals;
                    
                    if (!xValues || xValues.length === 0 || !residuals || residuals.length === 0) {
                        console.error('Empty residual data');
                        return;
                    }
                    
                    // Create residual plot data points
                    const dataPoints = xValues.map((x, i) => ({
                        x: x,
                        y: residuals[i]
                    }));
                    
                    // Sort data points by x value for the zero line
                    const sortedData = [...dataPoints].sort((a, b) => a.x - b.x);
                    const minX = sortedData[0].x;
                    const maxX = sortedData[sortedData.length - 1].x;
                    
                    // Find min and max for y-axis
                    const maxAbsResidual = Math.max(...residuals.map(Math.abs));
                    
                    // Create chart options
                    const residualOptions = {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Residual Plot for Linearity Assessment',
                                font: {
                                    size: 14
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `Residual: ${context.parsed.y.toFixed(2)} at ${context.parsed.x.toFixed(1)}`;
                                    }
                                }
                            },
                            watermark: {
                                image: usingDummyData ? createExampleWatermark() : null
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: analysisResults.currentAnalyzerName
                                },
                                beginAtZero: false
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Residuals'
                                },
                                min: -maxAbsResidual * 1.2,
                                max: maxAbsResidual * 1.2,
                                beginAtZero: false,
                                grid: {
                                    color: function(context) {
                                        return context.tick.value === 0 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                    },
                                    lineWidth: function(context) {
                                        return context.tick.value === 0 ? 2 : 1;
                                    }
                                }
                            }
                        }
                    };
                    
                    // Create residual plot data
                    const residualChartData = {
                        datasets: [
                            {
                                label: 'Residuals',
                                data: dataPoints,
                                borderColor: 'rgba(153, 102, 255, 1)',
                                backgroundColor: 'rgba(153, 102, 255, 0.5)',
                                borderWidth: 1,
                                pointRadius: 4,
                                pointHoverRadius: 6,
                                pointStyle: 'circle'
                            },
                            {
                                label: 'Zero Line',
                                data: [
                                    { x: minX, y: 0 },
                                    { x: maxX, y: 0 }
                                ],
                                borderColor: 'rgba(128, 128, 128, 0.7)',
                                borderWidth: 1,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                fill: false
                            }
                        ]
                    };
                    
                    // Create the Canvas element
                    const residualChart = document.getElementById('residualChart');
                    
                    // Create chart
                    residualChartInstance = new Chart(residualChart, {
                        type: 'scatter',
                        data: residualChartData,
                        options: residualOptions
                    });
                    
                    console.log('Residual chart created');
                } catch (error) {
                    console.error('Error creating residual plot:', error);
                }
            }
            
            function updateCharts() {
                if (analysisResults) {
                    drawCharts();
                }
            }
            
            // Export results to PDF
            function exportToPDF() {
                if (!analysisResults) return;
                
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 15;
                let yPos = margin;
                
                // Add title
                pdf.setFontSize(16);
                pdf.text('Method Comparison Report', pageWidth / 2, yPos, { align: 'center' });
                yPos += 10;
                
                // Add analyzer info
                pdf.setFontSize(12);
                pdf.text(`${analysisResults.currentAnalyzerName} vs ${analysisResults.newAnalyzerName}`, pageWidth / 2, yPos, { align: 'center' });
                yPos += 15;
                
                // Get selected confidence interval for Passing-Bablok
                const selectedCI = ciSelector.value;
                const ciLevel = selectedCI === '95' ? '95' : '90';
                const ciLevelDisplay = selectedCI === '95' ? '95%' : '90%';
                
                // Add regression stats
                pdf.setFontSize(14);
                pdf.text('Passing-Bablok Regression', margin, yPos);
                yPos += 8;
                
                pdf.setFontSize(10);
                pdf.text(`Regression Equation: ${analysisResults.regression.equation}`, margin, yPos);
                yPos += 6;
                pdf.text(`Slope: ${analysisResults.regression.slope.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`p-value (Slope≠1): ${analysisResults.regression.slopePValue.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`${ciLevelDisplay} CI for Slope: ${analysisResults.regression.confidenceIntervals[`slope${ciLevel}`].lower.toFixed(4)} to ${analysisResults.regression.confidenceIntervals[`slope${ciLevel}`].upper.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`Intercept: ${analysisResults.regression.intercept.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`p-value (Intercept≠0): ${analysisResults.regression.interceptPValue.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`${ciLevelDisplay} CI for Intercept: ${analysisResults.regression.confidenceIntervals[`intercept${ciLevel}`].lower.toFixed(4)} to ${analysisResults.regression.confidenceIntervals[`intercept${ciLevel}`].upper.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`Correlation Coefficient (r): ${analysisResults.regression.r.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`CUSUM Test p-value: ${analysisResults.regression.cusum.pValue.toFixed(4)} ${parseFloat(analysisResults.regression.cusum.pValue) >= 0.05 ? '(Linearity supported)' : '(Non-linearity detected)'}`, margin, yPos);
                yPos += 15;
                
                // Add regression chart
                const scatterCanvas = document.getElementById('scatterChart');
                const scatterImgData = scatterCanvas.toDataURL('image/png');
                pdf.addImage(scatterImgData, 'PNG', margin, yPos, pageWidth - (margin * 2), 70);
                yPos += 90;
                
                // Add CUSUM and Residual plots to first page
                // Add CUSUM plot
                pdf.setFontSize(14);
                pdf.text('CUSUM Test for Linearity', margin, yPos);
                yPos += 8;
                
                // Get CUSUM statistics from analysis results
                const cusumStat = analysisResults.regression.cusum.statistic.toFixed(4);
                const cusumPValue = analysisResults.regression.cusum.pValue.toFixed(4);
                const cusumValues = analysisResults.regression.cusum.values;
                const maxAbsCusum = Math.max(...cusumValues.map(Math.abs)).toFixed(2);
                
                pdf.setFontSize(10);
                pdf.text(`CUSUM Test p-value: ${cusumPValue} ${parseFloat(cusumPValue) >= 0.05 ? '(Linearity supported)' : '(Non-linearity detected)'}`, margin, yPos);
                yPos += 10;
                
                // Add CUSUM chart
                const cusumCanvas = document.getElementById('cusumChart');
                const cusumImgData = cusumCanvas.toDataURL('image/png');
                pdf.addImage(cusumImgData, 'PNG', margin, yPos, pageWidth - (margin * 2), 40);
                
                // Add data summary at the bottom of page 1
                yPos = pageHeight - 30;
                pdf.setFontSize(9);
                pdf.text(`Data Summary: ${analysisResults.pairedData.length} paired observations`, margin, yPos);
                yPos += 5;
                const currentValues = analysisResults.pairedData.map(pair => pair.current);
                const newValues = analysisResults.pairedData.map(pair => pair.new);
                const minCurrent = Math.min(...currentValues).toFixed(2);
                const maxCurrent = Math.max(...currentValues).toFixed(2);
                const minNew = Math.min(...newValues).toFixed(2);
                const maxNew = Math.max(...newValues).toFixed(2);
                pdf.text(`${analysisResults.currentAnalyzerName} range: ${minCurrent} - ${maxCurrent} | ${analysisResults.newAnalyzerName} range: ${minNew} - ${maxNew}`, margin, yPos);
                
                // Date at bottom of page 1
                pdf.setFontSize(8);
                pdf.text(`Generated on: ${new Date().toLocaleString()} (Page 1 of 2)`, margin, pageHeight - margin);
                
                // Start page 2 for Bland-Altman analysis
                pdf.addPage();
                yPos = margin;
                
                // Add title to page 2
                pdf.setFontSize(16);
                pdf.text('Method Comparison Report', pageWidth / 2, yPos, { align: 'center' });
                yPos += 10;
                
                // Add analyzer info
                pdf.setFontSize(12);
                pdf.text(`${analysisResults.currentAnalyzerName} vs ${analysisResults.newAnalyzerName}`, pageWidth / 2, yPos, { align: 'center' });
                yPos += 15;
                
                // Get selected confidence interval for Bland-Altman
                const baCILevel = baCISelector.value;
                const baLevel = baCILevel === '95' ? '95' : '90';
                const baLevelDisplay = baCILevel === '95' ? '95%' : '90%';
                
                // Add Bland-Altman stats
                pdf.setFontSize(14);
                pdf.text('Bland-Altman Analysis', margin, yPos);
                yPos += 8;
                
                pdf.setFontSize(10);
                pdf.text(`Mean Difference (Bias): ${analysisResults.blandAltman.meanDiff.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`${baLevelDisplay} CI for Bias: ${analysisResults.blandAltman[`limits${baLevel}`].biasCI.lower.toFixed(4)} to ${analysisResults.blandAltman[`limits${baLevel}`].biasCI.upper.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`Standard Deviation: ${analysisResults.blandAltman.stdDev.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`Upper Limit of Agreement: ${analysisResults.blandAltman[`limits${baLevel}`].upper.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`${baLevelDisplay} CI for Upper Limit: ${analysisResults.blandAltman[`limits${baLevel}`].upperCI.lower.toFixed(4)} to ${analysisResults.blandAltman[`limits${baLevel}`].upperCI.upper.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`Lower Limit of Agreement: ${analysisResults.blandAltman[`limits${baLevel}`].lower.toFixed(4)}`, margin, yPos);
                yPos += 6;
                pdf.text(`${baLevelDisplay} CI for Lower Limit: ${analysisResults.blandAltman[`limits${baLevel}`].lowerCI.lower.toFixed(4)} to ${analysisResults.blandAltman[`limits${baLevel}`].lowerCI.upper.toFixed(4)}`, margin, yPos);
                yPos += 15;
                
                // Add Bland-Altman chart
                const baCanvas = document.getElementById('blandAltmanChart');
                const baImgData = baCanvas.toDataURL('image/png');
                pdf.addImage(baImgData, 'PNG', margin, yPos, pageWidth - (margin * 2), 70);
                yPos += 80;
                
                // Add Residual plot
                pdf.setFontSize(14);
                pdf.text('Residual Plot for Linearity Assessment', margin, yPos);
                yPos += 8;
                
                pdf.setFontSize(10);
                pdf.text('Residual plot shows individual residuals vs. reference method values.', margin, yPos);
                yPos += 6;
                pdf.text('Random scatter around zero indicates linearity. Any visible pattern suggests non-linearity.', margin, yPos);
                yPos += 10;
                
                // Add Residual chart to PDF
                const residualCanvas = document.getElementById('residualChart');
                const residualImgData = residualCanvas.toDataURL('image/png');
                pdf.addImage(residualImgData, 'PNG', margin, yPos, pageWidth - (margin * 2), 50);
                
                // Date at bottom of page 2
                pdf.setFontSize(8);
                pdf.text(`Generated on: ${new Date().toLocaleString()} (Page 2 of 2)`, margin, pageHeight - margin);
                
                // Save the PDF
                pdf.save('analyzer-comparison-report.pdf');
            }
            
            // Export results to Word document
            function exportToWord() {
                // Check if html-docx-js library is available
                if (typeof htmlDocx === 'undefined') {
                    console.error('html-docx-js library is not loaded. Please check your internet connection.');
                    alert('Error: Could not load the required library for Word export. Please check your internet connection and try again.');
                    return;
                }
                
                if (!analysisResults) {
                    alert('No analysis results to export. Please run the analysis first.');
                    return;
                }
                
                // Create report container
                const reportContainer = document.createElement('div');
                
                // Get data for current and new analyzers
                const currentAnalyzerData = analysisResults.pairedData.map(pair => pair.current);
                const newAnalyzerData = analysisResults.pairedData.map(pair => pair.new);
                
                // Ensure charts are rendered with proper dimensions
                try {
                    // Reference all canvas elements
                    const passingBablokCanvas = document.getElementById('scatterChart');
                    const blandAltmanCanvas = document.getElementById('blandAltmanChart');
                    const cusumCanvas = document.getElementById('cusumChart');
                    const residualCanvas = document.getElementById('residualChart');
                    
                    // Create new temporary canvases for export
                    const tempCanvases = {
                        passingBablok: document.createElement('canvas'),
                        blandAltman: document.createElement('canvas'),
                        cusum: document.createElement('canvas'),
                        residual: document.createElement('canvas')
                    };
                    
                    // Set dimensions for main charts (16.2cm x 12cm at 96 DPI)
                    tempCanvases.passingBablok.width = 612; // 16.2cm * 37.8px/cm
                    tempCanvases.passingBablok.height = 454; // 12cm * 37.8px/cm
                    tempCanvases.blandAltman.width = 612;
                    tempCanvases.blandAltman.height = 454;
                    
                    // Set dimensions for smaller charts
                    tempCanvases.cusum.width = 529; // 14cm * 37.8px/cm
                    tempCanvases.cusum.height = 302; // 8cm * 37.8px/cm
                    tempCanvases.residual.width = 529;
                    tempCanvases.residual.height = 302;
                    
                    // Draw original canvas content onto temp canvases with white background
                    Object.keys(tempCanvases).forEach(key => {
                        const sourceCanvas = key === 'passingBablok' ? passingBablokCanvas :
                                          key === 'blandAltman' ? blandAltmanCanvas :
                                          key === 'cusum' ? cusumCanvas : residualCanvas;
                        
                        const ctx = tempCanvases[key].getContext('2d');
                        
                        // Fill white background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, tempCanvases[key].width, tempCanvases[key].height);
                        
                        // Draw the original chart content, scaled to fit
                        ctx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height, 
                                    0, 0, tempCanvases[key].width, tempCanvases[key].height);
                    });
                    
                    // Convert temp canvases to data URLs
                    const passingBablokImage = tempCanvases.passingBablok.toDataURL('image/png');
                    const blandAltmanImage = tempCanvases.blandAltman.toDataURL('image/png');
                    const cusumImage = tempCanvases.cusum.toDataURL('image/png');
                    const residualPlotImage = tempCanvases.residual.toDataURL('image/png');
                    
                    // Get selected confidence interval for Passing-Bablok
                    const selectedCI = ciSelector.value;
                    const ciLevel = selectedCI === '95' ? '95' : '90';
                    const ciLevelDisplay = selectedCI === '95' ? '95%' : '90%';
                    
                    // Get selected confidence interval for Bland-Altman
                    const baCILevel = baCISelector.value;
                    const baLevel = baCILevel === '95' ? '95' : '90';
                    const baLevelDisplay = baCILevel === '95' ? '95%' : '90%';
                    
                    // Create HTML content for the report
                    reportContainer.innerHTML = `
                    <style>
                        @page { size: A4; margin: 2cm; }
                        body { font-family: Arial, sans-serif; color: #333; line-height: 1.5; }
                        h1 { color: #1a365d; text-align: center; margin-bottom: 10px; font-size: 16pt; }
                        h2 { color: #1a365d; margin-top: 20px; font-size: 14pt; }
                        table { width: 100%; border-collapse: collapse; margin: 10px 0; }
                        th, td { padding: 8px; text-align: left; border: 1px solid #ddd; font-size: 10pt; }
                        th { background-color: #f5f5f5; }
                        .image-container { text-align: center; margin: 15px 0; page-break-inside: avoid; }
                        .note { font-style: italic; color: #777; font-size: 8pt; }
                        .page-break { page-break-before: always; }
                        p { font-size: 10pt; margin: 5px 0; }
                    </style>
                    
                    <!-- Page 1 -->
                    <h1>Method Comparison Report</h1>
                    <p style="text-align: center;">${analysisResults.currentAnalyzerName} vs ${analysisResults.newAnalyzerName}</p>
                    
                    <h2>Passing-Bablok Regression</h2>
                    <p>Regression Equation: ${analysisResults.regression.equation}</p>
                    <p>Slope: ${analysisResults.regression.slope.toFixed(4)}</p>
                    <p>p-value (Slope≠1): ${analysisResults.regression.slopePValue.toFixed(4)}</p>
                    <p>${ciLevelDisplay} CI for Slope: ${analysisResults.regression.confidenceIntervals[`slope${ciLevel}`].lower.toFixed(4)} to ${analysisResults.regression.confidenceIntervals[`slope${ciLevel}`].upper.toFixed(4)}</p>
                    <p>Intercept: ${analysisResults.regression.intercept.toFixed(4)}</p>
                    <p>p-value (Intercept≠0): ${analysisResults.regression.interceptPValue.toFixed(4)}</p>
                    <p>${ciLevelDisplay} CI for Intercept: ${analysisResults.regression.confidenceIntervals[`intercept${ciLevel}`].lower.toFixed(4)} to ${analysisResults.regression.confidenceIntervals[`intercept${ciLevel}`].upper.toFixed(4)}</p>
                    <p>Correlation Coefficient (r): ${analysisResults.regression.r.toFixed(4)}</p>
                    <p>CUSUM Test p-value: ${analysisResults.regression.cusum.pValue.toFixed(4)} ${parseFloat(analysisResults.regression.cusum.pValue) >= 0.05 ? '(Linearity supported)' : '(Non-linearity detected)'}</p>
                    
                    <div class="image-container">
                        <img src="${passingBablokImage}" alt="Passing-Bablok Regression Plot" width="612" height="454" style="width:16.2cm; height:12cm;">
                    </div>
                    
                    <h2>CUSUM Test for Linearity</h2>
                    <p>CUSUM Test p-value: ${analysisResults.regression.cusum.pValue.toFixed(4)} ${parseFloat(analysisResults.regression.cusum.pValue) >= 0.05 ? '(Linearity supported)' : '(Non-linearity detected)'}</p>
                    
                    <div class="image-container">
                        <img src="${cusumImage}" alt="CUSUM Test Plot" width="529" height="302" style="width:14cm; height:8cm;">
                    </div>
                    
                    <p style="font-size: 9pt;">Data Summary: ${analysisResults.pairedData.length} paired observations</p>
                    <p style="font-size: 9pt;">${analysisResults.currentAnalyzerName} range: ${Math.min(...currentAnalyzerData).toFixed(2)} - ${Math.max(...currentAnalyzerData).toFixed(2)} | ${analysisResults.newAnalyzerName} range: ${Math.min(...newAnalyzerData).toFixed(2)} - ${Math.max(...newAnalyzerData).toFixed(2)}</p>
                    
                    <p class="note" style="position: absolute; bottom: 15mm; left: 15mm;">Generated on: ${new Date().toLocaleString()} (Page 1 of 2)</p>
                    
                    <!-- Page 2 -->
                    <div class="page-break"></div>
                    <h1>Method Comparison Report</h1>
                    <p style="text-align: center;">${analysisResults.currentAnalyzerName} vs ${analysisResults.newAnalyzerName}</p>
                    
                    <h2>Bland-Altman Analysis</h2>
                    <p>Mean Difference (Bias): ${analysisResults.blandAltman.meanDiff.toFixed(4)}</p>
                    <p>${baLevelDisplay} CI for Bias: ${analysisResults.blandAltman[`limits${baLevel}`].biasCI.lower.toFixed(4)} to ${analysisResults.blandAltman[`limits${baLevel}`].biasCI.upper.toFixed(4)}</p>
                    <p>Standard Deviation: ${analysisResults.blandAltman.stdDev.toFixed(4)}</p>
                    <p>Upper Limit of Agreement: ${analysisResults.blandAltman[`limits${baLevel}`].upper.toFixed(4)}</p>
                    <p>${baLevelDisplay} CI for Upper Limit: ${analysisResults.blandAltman[`limits${baLevel}`].upperCI.lower.toFixed(4)} to ${analysisResults.blandAltman[`limits${baLevel}`].upperCI.upper.toFixed(4)}</p>
                    <p>Lower Limit of Agreement: ${analysisResults.blandAltman[`limits${baLevel}`].lower.toFixed(4)}</p>
                    <p>${baLevelDisplay} CI for Lower Limit: ${analysisResults.blandAltman[`limits${baLevel}`].lowerCI.lower.toFixed(4)} to ${analysisResults.blandAltman[`limits${baLevel}`].lowerCI.upper.toFixed(4)}</p>
                    
                    <div class="image-container">
                        <img src="${blandAltmanImage}" alt="Bland-Altman Plot" width="612" height="454" style="width:16.2cm; height:12cm;">
                    </div>
                    
                    <h2>Residual Plot for Linearity Assessment</h2>
                    <p>Residual plot shows individual residuals vs. reference method values.</p>
                    <p>Random scatter around zero indicates linearity. Any visible pattern suggests non-linearity.</p>
                    
                    <div class="image-container">
                        <img src="${residualPlotImage}" alt="Residual Plot" width="529" height="302" style="width:14cm; height:8cm;">
                    </div>
                    
                    <p class="note" style="position: absolute; bottom: 15mm; left: 15mm;">Generated on: ${new Date().toLocaleString()} (Page 2 of 2)</p>
                    `;
                    
                    // Create the Word document
                    const converted = htmlDocx.asBlob(reportContainer.innerHTML);
                    saveAs(converted, 'Method_Comparison_Report.docx');
                    console.log('Word document created successfully');
                } catch (error) {
                    console.error('Error creating Word document:', error);
                    alert('Error creating Word document. Please try again.');
                }
            }
            
            // Implement chart download functionality
            function setupChartDownloads() {
                // Get all download buttons
                const downloadButtons = document.querySelectorAll('.chart-download-btn');
                
                // Add click event to each button
                downloadButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        // Toggle the display of download options
                        const options = this.nextElementSibling;
                        options.style.display = options.style.display === 'none' ? 'block' : 'none';
                    });
                });
                
                // Add click event to each download format option
                const downloadFormats = document.querySelectorAll('.download-format');
                downloadFormats.forEach(format => {
                    format.addEventListener('click', function() {
                        const chartId = this.getAttribute('data-chart');
                        const fileFormat = this.getAttribute('data-format');
                        downloadChart(chartId, fileFormat);
                        
                        // Hide the options after selection
                        this.parentElement.style.display = 'none';
                    });
                });
            }
            
            function downloadChart(chartId, format) {
                const canvas = document.getElementById(chartId);
                
                // Create a new offscreen canvas to ensure white background
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = canvas.width;
                offscreenCanvas.height = canvas.height;
                
                // Get context and fill with white background
                const ctx = offscreenCanvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                
                // Draw the original chart on top of the white background
                ctx.drawImage(canvas, 0, 0);
                
                // Create download link
                let downloadLink = document.createElement('a');
                
                // Determine MIME type and filename based on format
                let mimeType = format === 'png' ? 'image/png' : 'image/jpeg';
                let fileName = chartId === 'scatterChart' ? 'passing-bablok-chart' : 'bland-altman-chart';
                fileName += `.${format}`;
                
                // Set quality for JPEG (doesn't affect PNG)
                let quality = format === 'jpeg' ? 0.95 : undefined;
                
                // Get chart image data with specified format and quality from the offscreen canvas
                let imageURL = offscreenCanvas.toDataURL(mimeType, quality);
                
                // Configure download link
                downloadLink.href = imageURL;
                downloadLink.download = fileName;
                
                // Trigger download
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
            }
            
            // Load dummy data on page load for demonstration
            function loadDummyData() {
                // Set flag to indicate we're using dummy data
                usingDummyData = true;
                
                // Add example overlay to charts and configuration
                document.getElementById('axisConfigCard').classList.add('example-overlay');
                document.getElementById('scatterChartContainer').classList.add('example-overlay');
                document.getElementById('blandAltmanChartContainer').classList.add('example-overlay');
                document.getElementById('regressionStats').classList.add('example-overlay');
                document.getElementById('blandAltmanStats').classList.add('example-overlay');
                document.getElementById('cusumChartContainer').classList.add('example-overlay');
                document.getElementById('residualChartContainer').classList.add('example-overlay');
                
                // Disable export and update chart buttons when using dummy data
                exportButton.disabled = true;
                updateChartButton.disabled = true;
                
                excelData = [];
                
                // Create 30 data points
                for (let i = 0; i < 30; i++) {
                    const current = 5 + Math.random() * 120;
                    const noise = (Math.random() - 0.5) * 20;
                    const new_val = current * 1.05 + 2 + noise;
                    
                    excelData.push({
                        'Sample': i + 1,
                        'Reference Method': current,
                        'Test Method': new_val
                    });
                }
                
                // Set columns
                columns = ['Sample', 'Reference Method', 'Test Method'];
                
                // Populate select dropdowns
                populateSelectOptions(currentAnalyzerSelect, columns);
                populateSelectOptions(newAnalyzerSelect, columns);
                
                // Enable selects
                currentAnalyzerSelect.disabled = false;
                newAnalyzerSelect.disabled = false;
                
                // Set default selections
                currentAnalyzerSelect.value = 'Reference Method';
                newAnalyzerSelect.value = 'Test Method';
                
                // Enable analyze button for example data
                analyzeButton.disabled = false;
                
                // Set analyzer names
                currentAnalyzerInput.value = 'Reference Method';
                newAnalyzerInput.value = 'Test Method';
            }
            
            // Add event listener for the example button
            document.querySelector('.example-button').addEventListener('click', toggleExample);
            
            // Setup chart download functionality
            setupChartDownloads();
            
            // Functions to update confidence interval display
            function updateConfidenceIntervals() {
                if (analysisResults) {
                    displayResults();
                }
            }
            
            // Initialize when DOM is loaded
            document.addEventListener('DOMContentLoaded', init);
            
            // Init function to ensure everything is properly set up
            function init() {
                // Register the watermark plugin with Chart.js
                Chart.register(watermarkPlugin);
                
                // Setup chart download functionality
                setupChartDownloads();
                
                // Load dummy data on page load for demonstration
                loadDummyData();
            }
            
            // Create watermark plugin and helper functions
            function createExampleWatermark() {
                // Create a canvas for the watermark
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions (for the watermark image)
                canvas.width = 200;
                canvas.height = 80;
                
                // Transparent background
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Style for the text
                ctx.fillStyle = 'rgba(200, 200, 200, 0.4)';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw the text
                ctx.fillText('EXAMPLE', canvas.width / 2, canvas.height / 2);
                
                return canvas;
            }
            
            // Watermark plugin for Chart.js
            const watermarkPlugin = {
                id: 'watermark',
                beforeDraw: (chart) => {
                    if (!chart.options.plugins.watermark || !chart.options.plugins.watermark.image) {
                        return;
                    }
                    
                    const image = chart.options.plugins.watermark.image;
                    const ctx = chart.ctx;
                    const { chartArea } = chart;
                    
                    const x = (chartArea.left + chartArea.right) / 2 - image.width / 2;
                    const y = (chartArea.top + chartArea.bottom) / 2 - image.height / 2;
                    
                    // Draw the watermark
                    ctx.globalAlpha = 0.3; // 30% opacity
                    ctx.drawImage(image, x, y);
                    ctx.globalAlpha = 1.0; // Reset alpha
                }
            };
            
            // Update the results section with the analysis results
            function updateResults(results) {
                analysisResults = results;
                
                // Enable the export buttons
                document.getElementById('exportButton').disabled = false;
                document.getElementById('exportWordButton').disabled = false;
                
                // Display the results div
                document.getElementById('resultsContainer').style.display = 'block';
                
                // Format and display the results
                // ... existing code ...
            }

            // Add toggle function at the beginning of the script
            function toggleInfo() {
                const overlay = document.getElementById('infoOverlay');
                if (overlay.style.display === 'flex') {
                    overlay.style.display = 'none';
                    document.body.style.overflow = 'auto';
                } else {
                    overlay.style.display = 'flex';
                    document.body.style.overflow = 'hidden';
                }
            }

            // Close modal when clicking outside
            document.getElementById('infoOverlay').addEventListener('click', function(e) {
                if (e.target === this) {
                    toggleInfo();
                }
            });

            // Add escape key listener to close modal
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('infoOverlay').style.display === 'flex') {
                    toggleInfo();
                }
            });

            // Add function to toggle example sections
            function toggleExample() {
                const exampleButton = document.querySelector('.example-button');
                const resultsContainer = document.getElementById('resultsContainer');
                
                if (exampleButton.textContent === 'Click to show example') {
                    // Load and analyze dummy data
                    loadDummyData();
                    
                    // Set the flag for dummy data (for free analysis)
                    usingDummyData = true;
                    
                    // Call the analysis function directly without token check
                    performAnalysis(currentAnalyzerSelect.value, newAnalyzerSelect.value);
                    
                    // Add example overlay to all sections
                    setTimeout(() => {
                        const sections = [
                            'axisConfigCard',
                            'scatterChartContainer',
                            'blandAltmanChartContainer',
                            'regressionStats',
                            'blandAltmanStats',
                            'cusumChartContainer',
                            'residualChartContainer',
                            'sampleCountCard',
                            'summarySectionCard',
                            'currentResultsCard'
                        ];
                        
                        sections.forEach(sectionId => {
                            const element = document.getElementById(sectionId);
                            if (element) {
                                element.classList.add('example-overlay');
                            }
                        });
                    }, 100);
                    
                    exampleButton.textContent = 'Hide example';
                    resultsContainer.style.display = 'block';
                } else {
                    // Remove example overlay from all sections
                    const sections = [
                        'axisConfigCard',
                        'scatterChartContainer',
                        'blandAltmanChartContainer',
                        'regressionStats',
                        'blandAltmanStats',
                        'cusumChartContainer',
                        'residualChartContainer',
                        'sampleCountCard',
                        'summarySectionCard',
                        'currentResultsCard'
                    ];
                    
                    sections.forEach(sectionId => {
                        const element = document.getElementById(sectionId);
                        if (element) {
                            element.classList.remove('example-overlay');
                        }
                    });
                    
                    exampleButton.textContent = 'Click to show example';
                    resultsContainer.style.display = 'none';
                    resetUI();
                }
            }

            function showHelp() {
                const helpModal = document.createElement('div');
                helpModal.className = 'help-modal';
                helpModal.innerHTML = `
                    <div class="help-modal-content">
                        <span class="help-modal-close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                        <h2>Help Guide</h2>
                        <h3>Getting Started</h3>
                        <p>1. Upload your Excel file containing paired data</p>
                        <p>2. Select the columns for Current and New Analyzer</p>
                        <p>3. Click "Analyze" to generate the comparison results</p>
                        
                        <h3>Excel File Requirements</h3>
                        <p>- Data should be in a tabular format</p>
                        <p>- Each row should contain paired measurements</p>
                        <p>- Missing values will be automatically filtered out</p>
                        
                        <h3>Features</h3>
                        <p>- Scatter Plot: Visual comparison of measurements</p>
                        <p>- Bland-Altman Plot: Shows agreement between methods</p>
                        <p>- CUSUM Plot: Detects systematic errors</p>
                        <p>- Residual Plot: Shows error distribution</p>
                        
                        <h3>Export Options</h3>
                        <p>- Export to Word: Generate a comprehensive report</p>
                        <p>- Export to Excel: Save analysis results</p>
                    </div>
                `;
                document.body.appendChild(helpModal);
            }

            // Add event listeners for input method selection
            const excelInputRadio = document.getElementById('excelInputRadio');
            const directInputRadio = document.getElementById('directInputRadio');
            const excelInputSection = document.getElementById('excelInputSection');
            const directInputSection = document.getElementById('directInputSection');
            const directDataInput = document.getElementById('directDataInput');
            
            // Add event listeners for input method toggle
            excelInputRadio.addEventListener('change', function() {
                document.getElementById('excelInputSection').style.display = 'block';
                document.getElementById('directInputSection').style.display = 'none';
                analyzeButton.disabled = true;
                currentAnalyzerSelect.disabled = true;
                newAnalyzerSelect.disabled = true;
                checkAnalyzeButton(); // Check button state after switching
            });

            directInputRadio.addEventListener('change', function() {
                document.getElementById('excelInputSection').style.display = 'none';
                document.getElementById('directInputSection').style.display = 'block';
                processDirectInput(); // Process any existing data when switching to direct input
                checkAnalyzeButton(); // Check button state after switching
            });

            // Add event listener for direct input changes
            directDataInput.addEventListener('input', function() {
                processDirectInput();
                checkAnalyzeButton(); // Check button state after input changes
            });

            // Function to process direct input data
            function processDirectInput() {
                const data = directDataInput.value.trim();
                const validationDiv = document.getElementById('inputValidation');
                
                if (!data) {
                    analyzeButton.disabled = true;
                    currentAnalyzerSelect.disabled = true;
                    newAnalyzerSelect.disabled = true;
                    validationDiv.style.display = 'none';
                    return;
                }

                try {
                    // Split into lines and process
                    const lines = data.split('\n').map(line => line.trim()).filter(line => line);
                    if (lines.length < 2) {
                        throw new Error('Please enter at least one row of data after the header row.');
                    }

                    const headers = lines[0].split(',').map(h => h.trim());
                    if (headers.length !== 2) {
                        throw new Error('Please include exactly two column headers.');
                    }
                    
                    // Create data array
                    const dataArray = [];
                    for (let i = 1; i < lines.length; i++) {
                        const values = lines[i].split(',').map(v => v.trim());
                        if (values.length === headers.length && values[0] && values[1]) {
                            const row = {};
                            headers.forEach((header, index) => {
                                const value = parseFloat(values[index]);
                                if (isNaN(value)) {
                                    throw new Error(`Invalid number in row ${i + 1}: ${values[index]}`);
                                }
                                row[header] = value;
                            });
                            dataArray.push(row);
                        }
                    }

                    if (dataArray.length === 0) {
                        throw new Error('No valid data rows found.');
                    }

                    // Update dropdowns
                    columns = headers;
                    currentAnalyzerSelect.innerHTML = '<option value="">Select a column...</option>';
                    newAnalyzerSelect.innerHTML = '<option value="">Select a column...</option>';
                    
                    columns.forEach(column => {
                        currentAnalyzerSelect.add(new Option(column, column));
                        newAnalyzerSelect.add(new Option(column, column));
                    });

                    // Enable selects and button
                    currentAnalyzerSelect.disabled = false;
                    newAnalyzerSelect.disabled = false;
                    analyzeButton.disabled = false;
                    validationDiv.style.display = 'none';

                    // Store the processed data
                    excelData = dataArray;

                    // Auto-select the first column for current analyzer
                    if (columns.length > 0) {
                        currentAnalyzerSelect.value = columns[0];
                        currentAnalyzerInput.value = columns[0];
                    }
                    
                    // Auto-select the second column for new analyzer
                    if (columns.length > 1) {
                        newAnalyzerSelect.value = columns[1];
                        newAnalyzerInput.value = columns[1];
                    }

                    // Check analyze button state
                    checkAnalyzeButton();

                } catch (error) {
                    console.error('Error processing direct input:', error);
                    analyzeButton.disabled = true;
                    currentAnalyzerSelect.disabled = true;
                    newAnalyzerSelect.disabled = true;
                    validationDiv.textContent = error.message;
                    validationDiv.style.display = 'block';
                }
            }

            // Update analyze button click handler
            analyzeButton.addEventListener('click', function() {
                if (directInputRadio.checked) {
                    // For direct input, process the data first
                    processDirectInput();
                }

                if (!currentAnalyzerSelect.value || !newAnalyzerSelect.value) {
                    alert('Please select both columns for analysis.');
                    return;
                }

                if (!excelData || excelData.length === 0) {
                    alert('No data available for analysis.');
                    return;
                }

                // Get method names from input fields
                const currentMethodName = document.getElementById('currentAnalyzerInput').value || 'Reference Method';
                const newMethodName = document.getElementById('newAnalyzerInput').value || 'Test Method';

                // Process the data and perform analysis
                const pairedData = excelData.map(row => ({
                    current: row[currentAnalyzerSelect.value],
                    new: row[newAnalyzerSelect.value]
                }));

                // Store the method names for use in analysis
                currentAnalyzerName = currentMethodName;
                newAnalyzerName = newMethodName;

                // Call the analyzeData function
                analyzeData();
            });

            // Token Purchase Modal Functions
            window.showTokenPurchaseModal = function() {
                const modal = document.getElementById('tokenPurchaseModal');
                if (!modal) return;
                
                modal.style.display = 'flex';
                document.body.style.overflow = 'hidden';
                
                // Reset selection
                window.selectedTokenPackage = 0;
                document.querySelectorAll('.token-package').forEach(pkg => {
                    pkg.classList.remove('selected');
                });
                
                // Disable purchase button
                document.getElementById('purchaseButton').disabled = true;
            };
            
            window.closeTokenPurchaseModal = function() {
                const modal = document.getElementById('tokenPurchaseModal');
                if (!modal) return;
                
                modal.style.display = 'none';
                document.body.style.overflow = 'auto';
            };
            
            window.selectTokenPackage = function(tokens) {
                window.selectedTokenPackage = tokens;
                
                // Update selected visual
                document.querySelectorAll('.token-package').forEach(pkg => {
                    pkg.classList.remove('selected');
                });
                
                // Find the clicked package and select it
                document.querySelectorAll('.token-package').forEach(pkg => {
                    const tokenCount = pkg.querySelector('.token-count').textContent;
                    if (parseInt(tokenCount) === tokens) {
                        pkg.classList.add('selected');
                    }
                });
                
                // Enable purchase button
                const purchaseButton = document.getElementById('purchaseButton');
                if (purchaseButton) {
                    purchaseButton.disabled = false;
                }
            };
            
            // Handle logout
            window.handleLogout = async function() {
                try {
                    const { error } = await window.supabaseClient.auth.signOut();
                    if (error) {
                        console.error('Logout error:', error);
                    } else {
                        updateUIForAuthState(false);
                    }
                } catch (err) {
                    console.error('Unexpected logout error:', err);
                }
            };
        });
    </script>
    <!-- Authentication Modal -->
    <div class="auth-modal-overlay" id="authModal">
        <div class="auth-modal">
            <button class="close-button" onclick="toggleAuthModal(false)">&times;</button>
            
            <!-- Login Form -->
            <form id="loginForm" class="auth-form">
                <h2>Login to LabValid</h2>
                <div class="form-group">
                    <label for="loginEmail">Email</label>
                    <input type="email" id="loginEmail" required placeholder="your@email.com">
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password</label>
                    <input type="password" id="loginPassword" required placeholder="••••••••">
                </div>
                <button type="submit">Login</button>
                <div class="auth-toggle">
                    <div style="margin-bottom: 10px;">
                        <a onclick="toggleForms('resetPassword')" style="cursor: pointer; color: var(--primary-color);">Forgot Password?</a>
                    </div>
                    Don't have an account? <a onclick="toggleForms('signup')">Sign Up</a>
                </div>
                <div class="auth-message" id="loginMessage"></div>
            </form>
            
            <!-- Signup Form -->
            <form id="signupForm" class="auth-form" style="display: none;">
                <h2>Create a LabValid Account</h2>
                <div class="form-group">
                    <label for="signupEmail">Email</label>
                    <input type="email" id="signupEmail" required placeholder="your@email.com">
                </div>
                <div class="form-group">
                    <label for="signupPassword">Password</label>
                    <input type="password" id="signupPassword" required placeholder="••••••••">
                </div>
                
                <!-- Add hCaptcha -->
                <div class="form-group">
                    <div class="h-captcha" 
                         data-sitekey="43be7694-0268-4b9a-bbd0-eb3cd9ea1230"
                         data-callback="onHCaptchaSuccess"
                         data-error-callback="onHCaptchaError"
                         data-expired-callback="hcaptcha.reset"></div>
                </div>
                
                <button type="submit">Create Account</button>
                <div class="auth-toggle">
                    Already have an account? <a onclick="toggleForms('login')">Login</a>
                </div>
                <div class="auth-message" id="signupMessage"></div>
            </form>
            
            <!-- Password Reset Form -->
            <form id="resetPasswordForm" class="auth-form" style="display: none;">
                <h2>Reset Your Password</h2>
                <p style="text-align: center; margin-bottom: 20px;">Enter your email address and we'll send you instructions to reset your password.</p>
                <div class="form-group">
                    <label for="resetEmail">Email</label>
                    <input type="email" id="resetEmail" required placeholder="your@email.com">
                </div>
                
                <button type="submit">Send Reset Instructions</button>
                <div class="auth-toggle">
                    <a onclick="toggleForms('login')">Back to Login</a>
                </div>
                <div class="auth-message" id="resetMessage"></div>
            </form>
        </div>
    </div>
    
    <!-- Authentication JavaScript -->
    <script>
    window.addEventListener('error', function(e) {
        if (e.target.tagName === 'SCRIPT') {
            console.error('Script loading error for:', e.target.src);
        }
    }, true);
    </script>

    <!-- Token Purchase Modal -->
    <div id="tokenPurchaseModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <button class="modal-close" onclick="closeTokenPurchaseModal()">&times;</button>
            <h2>Purchase Tokens</h2>
            <p>Select a token package to purchase:</p>
            
            <div class="token-packages">
                <div class="token-package" onclick="selectTokenPackage(5)">
                    <div class="token-count">5</div>
                    <div class="token-price">$5.99</div>
                    <div class="token-label">Basic</div>
                </div>
                <div class="token-package" onclick="selectTokenPackage(20)">
                    <div class="token-count">20</div>
                    <div class="token-price">$19.99</div>
                    <div class="token-label">Popular</div>
                    <div class="token-badge">20% OFF</div>
                </div>
                <div class="token-package" onclick="selectTokenPackage(50)">
                    <div class="token-count">50</div>
                    <div class="token-price">$39.99</div>
                    <div class="token-label">Pro</div>
                    <div class="token-badge">33% OFF</div>
                </div>
            </div>
            
            <div class="token-purchase-footer">
                <button id="purchaseButton" class="purchase-button" disabled>
                    Purchase Tokens
                </button>
            </div>
        </div>
    </div>
    
    <div class="card">
    <!-- Token system fix script -->
    <script src="token-fix.js"></script>
</body>
</html>
